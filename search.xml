<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++模板</title>
      <link href="/2019/08/24/C-%E6%A8%A1%E6%9D%BF/"/>
      <url>/2019/08/24/C-%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="C-模板"><a href="#C-模板" class="headerlink" title="C++模板"></a>C++模板</h1><h3 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h3><p><strong>作为C++支持泛型的重要武器,模板被引入作为泛型编程的基础:</strong></p><p><strong>泛型编程：编写与类型无关的通用代码，是代码复用的一种手段。模板是泛型编程的基础。</strong></p><a id="more"></a><p><strong>模板又分为函数模板和类模板</strong></p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><h4 id="定义格式"><a href="#定义格式" class="headerlink" title="定义格式"></a>定义格式</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2,......,<span class="keyword">typename</span> Tn&gt;</span><br><span class="line">返回值类型 函数名(参数列表)&#123;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">( T&amp; left, T&amp; right)</span> </span>&#123; T temp = left;</span><br><span class="line">left = right;</span><br><span class="line">right = temp; &#125;</span><br></pre></td></tr></table></figure><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>编译器用使用方式产生特定具体类型函数的模具。所以其实模板 是将本来应该我们做的重复的事情交给了编译器</p><p><strong>在编译器编译阶段</strong>，对于模板函数的使用，<strong>编译器需要根据传入的实参类型来推演生成对应类型的函数</strong>以供 </p><p>调用。</p><h5 id="函数模板实例化"><a href="#函数模板实例化" class="headerlink" title="函数模板实例化:"></a>函数模板实例化:</h5><ul><li>隐式实例化：让编译器根据实参推演模板参数的实际类型，参数的类型要一致，要不需要显示实例化，或者参数列表添加参数</li><li>显式实例化：在函数名后的&lt;&gt;中指定模板参数的实际类型,如果类型不匹配，编译器会尝试进行隐式类型转换，如果无法转换成功编译器将会报错。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Add&lt;<span class="keyword">int</span>&gt; v;</span><br></pre></td></tr></table></figure><h5 id="模板参数匹配规则"><a href="#模板参数匹配规则" class="headerlink" title="模板参数匹配规则"></a>模板参数匹配规则</h5><ul><li>一个非模板函数可以和一个同名的函数模板同时存在，而且该函数模板还可以被实例化为这个非模板函数</li><li>对于非板函数和同名函数模板，如果其他条件都相同，在调动时会优先调用非模板函数而不会从该模板产生出一个实例。如果模板可以产生一个具有更好匹配的函数,那么将选择模板</li><li>模板函数不允许自动类型转换，但普通函数可以进行自动类型转换</li></ul><h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><h4 id="模板类的定义"><a href="#模板类的定义" class="headerlink" title="模板类的定义"></a>模板类的定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>, ..., <span class="title">class</span> <span class="title">Tn</span>&gt; </span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> 类模板名 </span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 类内成员定义 </span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意：类模板中函数放在类外进行定义时，需要加模板参数列表</strong></p><h5 id="类模板的实例化"><a href="#类模板的实例化" class="headerlink" title="类模板的实例化"></a>类模板的实例化</h5><p>类模板实例化与函数模板实例化不同，类模板实例化需要在类模板名字后跟<strong>&lt;&gt;</strong>，然后将实例化的类型放在&lt;&gt;</p><p>中即可，类模板名字不是真正的类，而实例化的结果才是真正的类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br></pre></td></tr></table></figure><h3 id="补充"><a href="#补充" class="headerlink" title="补充:"></a>补充:</h3><h5 id="非类型模板参数"><a href="#非类型模板参数" class="headerlink" title="非类型模板参数:"></a>非类型模板参数:</h5><p><strong>类型形参即</strong>：出现在模板参数列表中,跟在<strong>class</strong>或者<strong>typename</strong>之类的参数类型名称。 </p><p><strong>非类型形参</strong> :  就是用一个常量作为类(函数)模板的一个参数，在类(函数)模板中可将该参数当成常量来使用。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">size_t</span> <span class="title">N</span> <span class="title">N</span> = 10&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong> </p><ul><li>浮点数、类对象以及字符串是不允许作为非类型模板参数的。 </li><li>非类型的模板参数必须在编译期就能确认结果。 </li></ul><h5 id="类模板的特化"><a href="#类模板的特化" class="headerlink" title="类模板的特化"></a><strong>类模板的特化</strong></h5><h5 id="全特化"><a href="#全特化" class="headerlink" title="全特化"></a>全特化</h5><p>全特化即是将模板参数类表中所有参数都确定话</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">template</span>&lt;&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Data</span>&lt;int, char&gt;</span></span><br></pre></td></tr></table></figure><p> <strong>偏特化</strong> </p><p>偏特化：任何针对模版参数进一步进行条件限制设计的特化版本。比如对于以下模板类：</p><p>偏特化有以下两种表现方式： </p><h6 id="部分特化"><a href="#部分特化" class="headerlink" title="部分特化"></a>部分特化</h6><p>将模板参数类表中的一部分参数特化。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将第二个参数特化为int </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>&gt; </span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Data</span>&lt;T1, int&gt;</span></span><br></pre></td></tr></table></figure><h6 id="参数更进一步的限制"><a href="#参数更进一步的限制" class="headerlink" title="参数更进一步的限制"></a>参数更进一步的限制</h6><p>偏特化并不仅仅是指特化部分参数，而是针对模板参数更进一步的条件限制所设计出来的一个特化版本。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span> &lt;T1*, T2*&gt;</span></span><br></pre></td></tr></table></figure><h5 id="类模板特化应用之类型萃取"><a href="#类模板特化应用之类型萃取" class="headerlink" title="类模板特化应用之类型萃取"></a>类模板特化应用之类型萃取</h5><p>应用：解决拷贝问题：</p><h5 id="模板的分离编译"><a href="#模板的分离编译" class="headerlink" title="模板的分离编译"></a>模板的分离编译</h5><p>不支持直接分离编译，可以显示实例化（不推荐）；链接时出错</p><h4 id="模板的优缺点"><a href="#模板的优缺点" class="headerlink" title="模板的优缺点"></a>模板的优缺点</h4><p><strong>【优点】</strong> </p><p> 模板复用了代码，节省资源，更快的迭代开发，C++的标准模板库(STL)因此而产生</p><p>增强了代码的灵活性 </p><p><strong>【缺陷】</strong> </p><p> <strong>模板会导致代码膨胀问题，也会导致编译时间变长</strong> </p><p> <strong>出现模板编译错误时，错误信息非常凌乱，不易定位错误</strong> </p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++入门知识</title>
      <link href="/2019/08/24/C-%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86/"/>
      <url>/2019/08/24/C-%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="C-入门知识铺垫"><a href="#C-入门知识铺垫" class="headerlink" title="C++入门知识铺垫"></a>C++入门知识铺垫</h1><h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><h5 id="命名空间的作用"><a href="#命名空间的作用" class="headerlink" title="命名空间的作用"></a>命名空间的作用</h5><p>在C/C++中，变量、函数和后面要学到的类都是大量存在的，这些变量、函数和类的名称将都存在于全局作用 域中，可能会导致很多冲突。使用命名空间的目的是对标识符的名称进行本地化，以避免命名冲突或名字污 染，namespace关键字的出现就是针对这种问题的。</p><p>注意：一个命名空间就定义了一个新的作用域，命名空间中的所有内容都局限于该命名空间中</p><a id="more"></a><h5 id="命名空间的定义"><a href="#命名空间的定义" class="headerlink" title="命名空间的定义:"></a>命名空间的定义:</h5><p>关键字:namespace</p><p>namespace  N1{</p><p>……..</p><p>}</p><p>1.命名空间可以嵌套</p><p>2.同一个工程中允许存在多个相同名称的命名空间 ,编译器后会合成同一个命名空间中。 </p><h5 id="命名空间的使用"><a href="#命名空间的使用" class="headerlink" title="命名空间的使用:"></a>命名空间的使用:</h5><p>1.完全展开:</p><p>using namespace;</p><p>2.部分展开</p><p>using std::cout;</p><p>3.不展开</p><p> std :: cout&lt;&lt;”学习使我快乐”&lt;&lt; std:: end1;</p><h6 id="三种使用方式的区别"><a href="#三种使用方式的区别" class="headerlink" title="三种使用方式的区别"></a>三种使用方式的区别</h6><p>完全展开使用方便,但是还是会造成命名污染,部分展开适合在工程中应用,不展开使用麻烦但是不会有命名污染</p><h4 id="C-的输入和输出"><a href="#C-的输入和输出" class="headerlink" title="C++的输入和输出"></a>C++的输入和输出</h4><p>1.缺省参数</p><p>缺省参数是声明或定义函数时为函数的参数指定一个默认值。在调用该函数时，如果没有指定实参则采用该默 认值，否则使用指定的实参。</p><p>1.半缺省</p><p>2.全缺省</p><ol><li><p>半缺省参数必须从右往左依次来给出，不能间隔着给 </p><p>明确缺省的参数传值确定,传参是从左往右的</p></li><li><p>缺省参数不能在函数声明和定义中同时出现,如果生命与定义位置同时出现，恰巧两个位置提供的值不同，那编译器就无法确定到底该用那个缺省值。 </p></li></ol><p>2.函数重载:</p><p>   是函数的一种特殊情况，C++允许在同一作用域中声明几个功能类似的同名函数，这些同名函数的形 参列表(参数个数 或 类型 或 顺序)必须不同，常用来处理实现功能类似数据类型不同的问题</p><p>3.函数重载实现:</p><p>命名修饰规则:</p><p>和C语言不同,函数命名修饰时只是在函数名称前加了下划线,C++中还加入了参数类型的首字母这支持了函数重载</p><h4 id="extern-“c”"><a href="#extern-“c”" class="headerlink" title="extern “c”"></a>extern “c”</h4><p>C++向后兼容所以在c++编译器中是可以执行编译C语言代码的但是为了支持C风格的编译加上extren “C”‘.</p><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>引用不是新定义一个变量，而是给已存在变量取了一个别名，编译器不会为引用变量开辟内存空间，它和它引 用的变量共用同一块内存空间。注意：引用类型必须和引用实体是同种类型的</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = <span class="number">10</span><span class="comment">; </span></span><br><span class="line"></span><br><span class="line">int&amp; <span class="built_in">ra</span> = a<span class="comment">;</span></span><br></pre></td></tr></table></figure><h5 id="引用特性"><a href="#引用特性" class="headerlink" title="引用特性:"></a>引用特性:</h5><ol><li>引用在定义时必须初始化 </li><li>一个变量可以有多个引用 </li><li>引用一旦引用一个实体，再不能引用其他实体</li></ol><h5 id="引用的使用"><a href="#引用的使用" class="headerlink" title="引用的使用:"></a>引用的使用:</h5><p>1.传参，2.传返回值</p><p>注意：如果函数返回时，离开函数作用域后，其栈上空间已经还给系统，因此不能用栈上的空间作为引用类型 返回。如果以引用类型返回，返回值的生命周期必须不受函数的限制(即比函数生命周期长)。</p><h5 id="传值和传引用的区别"><a href="#传值和传引用的区别" class="headerlink" title="传值和传引用的区别"></a>传值和传引用的区别</h5><p> 以值作为参数或者返回值类型，在传参和返回期间，函数不会直接传递实参或者将变量本身直接返回，而是传递实 参或者返回变量的一份临时的拷贝，因此用值作为参数或者返回值类型，效率是非常低下的，尤其是当参数或者返回 值类型非常大时，效率就更低</p><h5 id="引用和指针的区别"><a href="#引用和指针的区别" class="headerlink" title="引用和指针的区别"></a>引用和指针的区别</h5><h6 id="引用的特点"><a href="#引用的特点" class="headerlink" title="引用的特点:"></a>引用的特点:</h6><p>在语法概念上引用就是一个别名，没有独立空间，和其引用实体共用同一块空间。</p><p>在底层实现上实际是有空间的，因为引用是按照指针方式来实现的。</p><h6 id="引用和指针的不同点"><a href="#引用和指针的不同点" class="headerlink" title="引用和指针的不同点:"></a>引用和指针的不同点:</h6><ol><li>引用在定义时必须初始化，指针没有要求</li><li>引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何一个同类型实 体</li><li>没有NULL引用，但有NULL指针 </li><li>在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数(32位平台下占4 个字节)</li><li>引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小 </li><li>有多级指针，但是没有多级引用 </li><li>访问实体方式不同，指针需要显式解引用，引用编译器自己处理</li><li>引用比指针使用起来相对更安全</li></ol><p><strong>引用的原理</strong>：</p><p>程序在编译时分别将指 针和引用添加到<strong>符号表</strong>上，符号表上记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为 引用对象的地址值。符号表生成后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。</p><h4 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h4><p>以inline修饰的函数叫做内联函数，编译时C++编译器会在调用内联函数的地方展开，没有函数压栈的开销， 内联函数提升程序运行的效率。(宏函数的升级)</p><p>使用:</p><p>函数前加inline关键字</p><p>特性:</p><ol><li>inline是一种以空间换时间的做法，省去调用函数额开销。所以代码很长或者有循环/递归的函数不适宜使 用作为内联函数。 </li><li>inline对于编译器而言只是一个建议，编译器会自动优化，如果定义为inline的函数体内有循环/递归等 等，编译器优化时会忽略掉内联。 </li><li>inline不建议声明和定义分离，分离会导致链接错误。因为inline被展开，就没有函数地址了，链接就会找 不到。</li></ol><h5 id="宏的优缺点"><a href="#宏的优缺点" class="headerlink" title="宏的优缺点"></a>宏的优缺点</h5><p>优点：</p><ul><li>提高了程序的可读性，同时也方便进行修改；</li><li>提高程序的运行效率：使用带参的宏定义既可完成函数调用的功能，又能避免函数的出栈与入栈操作，减少系统开销，提高运行效率；</li><li>宏是由预处理器处理的，通过字符串操作可以完成很多编译器无法实现的功能。比如##连接符。</li></ul><p>缺点：</p><ul><li>由于是直接嵌入的，所以代码可能相对多一点；</li><li>嵌套定义过多可能会影响程序的可读性，而且很容易出错；</li><li>对带参的宏而言，由于是直接替换，并不会检查参数是否合法，存在安全隐患。</li></ul><p>补充：预编译语句仅仅是简单的值代替，缺乏类型的检测机制。这样预处理语句就不能享受C++严格的类型检查的好处，从而可能成为引发一系列错误的隐患。的确，宏定义给我们带来很多方便之处，但是必须正确使用，否则，可能会出现一些意想不到的问题。</p><p><strong>最后，引用《C 陷进与缺陷》的一句话，对其进行总结：宏并不是函数, 宏并不是语句, 宏并不是类型定义</strong></p><h4 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h4><p>自动匹配类型值</p><p>注意:</p><p>auto 不能做函数参数,同一行定义多个变量时类型要相同</p><h4 id="范围for"><a href="#范围for" class="headerlink" title="范围for"></a>范围for</h4><p>使用时范围确定</p><h4 id="NULL和nullptr"><a href="#NULL和nullptr" class="headerlink" title="NULL和nullptr"></a>NULL和nullptr</h4><p>NULL是一个宏志为0,而nullptr是一个指针(void*)</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树小结</title>
      <link href="/2019/08/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B0%8F%E7%BB%93/"/>
      <url>/2019/08/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>顺序表小结</title>
      <link href="/2019/08/23/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%B0%8F%E7%BB%93/"/>
      <url>/2019/08/23/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="线性表相关总结"><a href="#线性表相关总结" class="headerlink" title="线性表相关总结"></a>线性表相关总结</h1><h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p>1.存储方式存在一段连续的空间</p><p>2.存储特点:逻辑关系相邻的两个结点在物理上也相邻</p><p>3.优点是可以随机访问 缺点是插入和删除不方便</p><a id="more"></a><h3 id="顺序表的结构"><a href="#顺序表的结构" class="headerlink" title="顺序表的结构:"></a>顺序表的结构:</h3><p><img src="C:\Users\VSAS\Desktop\数据结构\顺序表.png" alt=""></p><h2 id="相关操作"><a href="#相关操作" class="headerlink" title="相关操作:"></a>相关操作:</h2><h3 id="头插"><a href="#头插" class="headerlink" title="头插"></a>头插</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushFront</span><span class="params">(SeqList* seqlist, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">true<span class="comment">//检验数据合法性</span></span><br><span class="line">trueassert(seqlist != <span class="literal">NULL</span>);</span><br><span class="line">true<span class="comment">//判断是否容量不够</span></span><br><span class="line">true<span class="comment">//数据往后移动,从后往前移动防止数据被覆盖掉</span></span><br><span class="line">true<span class="keyword">for</span> (<span class="keyword">int</span> i = seqlist-&gt;size<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">truetrueseqlist-&gt;arr[i + <span class="number">1</span>] = seqlist-&gt;arr[i];</span><br><span class="line">true&#125;</span><br><span class="line">trueseqlist-&gt;arr[<span class="number">0</span>] = val;</span><br><span class="line">trueseqlist-&gt;size += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="尾插"><a href="#尾插" class="headerlink" title="尾插"></a>尾插</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pushback</span><span class="params">(SeqList* seqlist, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">true<span class="comment">//检验数据合法性</span></span><br><span class="line">trueassert(seqlist != <span class="literal">NULL</span>);</span><br><span class="line">trueseqlist-&gt;arr[seqlist-&gt;size] = val;</span><br><span class="line">trueseqlist-&gt;size += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="头删"><a href="#头删" class="headerlink" title="头删"></a>头删</h3><p><img src="C:\Users\VSAS\Desktop\数据结构\顺序表1.png" alt="图示"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PopFront</span><span class="params">(SeqList* seqlist)</span> </span>&#123;</span><br><span class="line">true<span class="comment">//数据从后往前移动</span></span><br><span class="line">true<span class="comment">//检验数据合法性</span></span><br><span class="line">trueassert(seqlist != <span class="literal">NULL</span>);</span><br><span class="line">true<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &gt;= seqlist-&gt;size<span class="number">-1</span>; --i) &#123;</span><br><span class="line">truetrueseqlist-&gt;arr[i] = seqlist-&gt;arr[i+<span class="number">1</span>];</span><br><span class="line">true&#125;</span><br><span class="line">trueseqlist-&gt;size -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="尾删"><a href="#尾删" class="headerlink" title="尾删"></a>尾删</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Popback</span><span class="params">(SeqList* seqlist)</span> </span>&#123;</span><br><span class="line">true<span class="comment">//检验数据合法性</span></span><br><span class="line">trueassert(seqlist != <span class="literal">NULL</span>);</span><br><span class="line">trueseqlist-&gt;size -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="任意位置插入"><a href="#任意位置插入" class="headerlink" title="任意位置插入"></a>任意位置插入</h3><p><img src="C:\Users\VSAS\Desktop\数据结构\顺序表2.bmp" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(SeqList* seqlist, <span class="keyword">int</span> pos, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">true<span class="comment">//检验数据合法性</span></span><br><span class="line">trueassert(seqlist != <span class="literal">NULL</span>);</span><br><span class="line">true<span class="keyword">for</span> (<span class="keyword">int</span> i = seqlist-&gt;size - <span class="number">1</span>; i &gt;= pos; --i) &#123;</span><br><span class="line">truetrueseqlist-&gt;arr[i + <span class="number">1</span>] = seqlist-&gt;arr[i];</span><br><span class="line">true&#125;</span><br><span class="line">trueseqlist-&gt;arr[pos] = val;</span><br><span class="line">trueseqlist-&gt;size += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="任意位置删除"><a href="#任意位置删除" class="headerlink" title="任意位置删除"></a>任意位置删除</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">(SeqList* seqlist, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">true<span class="comment">//检验数据合法性</span></span><br><span class="line">trueassert(seqlist != <span class="literal">NULL</span>);</span><br><span class="line">true<span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &gt;= seqlist-&gt;size - <span class="number">1</span>; --i) &#123;</span><br><span class="line">truetrueseqlist-&gt;arr[i] = seqlist-&gt;arr[i + <span class="number">1</span>];</span><br><span class="line">true&#125;</span><br><span class="line">trueseqlist-&gt;size -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>1.存储的空间可能不连续</p><p>2.方便增删</p><p>3.可能会更加节约空间</p><h3 id="链表的分类"><a href="#链表的分类" class="headerlink" title="链表的分类"></a>链表的分类</h3><p>1.有头结点的链表</p><p>2.循环链表</p><p>3.双向链表</p><h3 id="头插-1"><a href="#头插-1" class="headerlink" title="头插"></a>头插</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SListPushFront</span><span class="params">(SList* slist, SListDataType v)</span> </span>&#123;</span><br><span class="line">true<span class="comment">//开辟空间</span></span><br><span class="line">trueNode* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">truenode-&gt;value = v;</span><br><span class="line">truenode-&gt;next = slist-&gt;first;</span><br><span class="line">trueslist-&gt;first = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="尾插-1"><a href="#尾插-1" class="headerlink" title="尾插"></a>尾插</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushBack</span><span class="params">(SList* slist, SListDataType v)</span> </span>&#123;</span><br><span class="line">trueNode* news = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">truenews-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">truenews-&gt;value = v;</span><br><span class="line">true<span class="keyword">if</span> (slist-&gt;first = <span class="literal">NULL</span>) &#123;</span><br><span class="line">truetrueslist-&gt;first = news;</span><br><span class="line">true&#125;</span><br><span class="line">true<span class="keyword">else</span> &#123;</span><br><span class="line">truetrue<span class="comment">//查找最后一个结点</span></span><br><span class="line">truetrueNode* cur = slist-&gt;first;</span><br><span class="line">truetrue<span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">truetruetruecur = cur-&gt;next;</span><br><span class="line">truetrue&#125;</span><br><span class="line">truetruecur-&gt;next = news;</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="头删-1"><a href="#头删-1" class="headerlink" title="头删"></a>头删</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PopFront</span><span class="params">(Node *head)</span> </span>&#123;</span><br><span class="line">trueNode *second = head-&gt;next;</span><br><span class="line">true<span class="built_in">free</span>(head);</span><br><span class="line">truehead = second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="尾删-1"><a href="#尾删-1" class="headerlink" title="尾删"></a>尾删</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SListPopBack</span><span class="params">(SList *s)</span> </span>&#123;</span><br><span class="line">true<span class="comment">// 排除掉链表中一个结点都没有的情况</span></span><br><span class="line">trueassert(s-&gt;first != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">true<span class="keyword">if</span> (s-&gt;first-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">truetrue<span class="comment">// 只有一个结点</span></span><br><span class="line">truetrue<span class="built_in">free</span>(s-&gt;first);</span><br><span class="line">truetrues-&gt;first = <span class="literal">NULL</span>;</span><br><span class="line">truetrue<span class="keyword">return</span>;</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">true<span class="comment">// 找倒数第二个结点</span></span><br><span class="line">trueNode *c;</span><br><span class="line">true<span class="keyword">for</span> (c = s-&gt;first; c-&gt;next-&gt;next != <span class="literal">NULL</span>; c = c-&gt;next);</span><br><span class="line">true<span class="built_in">free</span>(c-&gt;next);</span><br><span class="line">truec-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相关总结"><a href="#相关总结" class="headerlink" title="相关总结"></a>相关总结</h3><p><strong>前序（上一个结点）        后继（下一个结点）</strong><br><strong>链表的代码有两个特点</strong></p><ol><li><strong>要操作某一个结点，往往需要找到这个结点的上一个结点(前驱结点)</strong></li><li><p><strong>操作链表的第一个结点，往往是特殊情况</strong></p><p>   <strong>针对第 2 个特点，有个取巧的办法在第一个结点前面加一个假的结点</strong></p></li></ol><h4 id="常见对链表的操作"><a href="#常见对链表的操作" class="headerlink" title="常见对链表的操作"></a>常见对链表的操作</h4><h5 id="1-逆转链表"><a href="#1-逆转链表" class="headerlink" title="1.逆转链表"></a>1.逆转链表</h5><p><img src="D:\MyBlog\source\images\链表逆置.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">reverseList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">trueNode* ret = <span class="literal">NULL</span>;</span><br><span class="line">trueNode* cur = head;</span><br><span class="line">true<span class="keyword">while</span> (cur != <span class="literal">NULL</span>)&#123;</span><br><span class="line">truetrueNode* next = cur-&gt;next;</span><br><span class="line">truetruecur-&gt;next = ret;</span><br><span class="line">truetrueret = cur;</span><br><span class="line">truetruecur = next;</span><br><span class="line">true&#125;</span><br><span class="line">true<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">reverseList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">trueNode* ret = <span class="literal">NULL</span>;</span><br><span class="line">trueNode* cur = head;</span><br><span class="line">true<span class="keyword">while</span> (cur != <span class="literal">NULL</span>)&#123;</span><br><span class="line">truetrue<span class="comment">//保存下一个节点的地址</span></span><br><span class="line">truetrueNode* next = cur-&gt;next;</span><br><span class="line">truetrue<span class="comment">//保存当前节点地址</span></span><br><span class="line">truetrueret = cur;</span><br><span class="line">truetrue<span class="comment">//交换</span></span><br><span class="line">truetruecur-&gt;next = ret;</span><br><span class="line">truetrue<span class="comment">//移动结点</span></span><br><span class="line">truetruecur = next;</span><br><span class="line">true&#125;</span><br><span class="line">true<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-删除遇到的所有值"><a href="#2-删除遇到的所有值" class="headerlink" title="2.删除遇到的所有值"></a>2.删除遇到的所有值</h5><p><strong>将遇到的不等于val的值单独组成一个链表</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RemoveAll</span><span class="params">(Node* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">trueNode* cur = head;</span><br><span class="line">trueNode* ret = <span class="literal">NULL</span>;</span><br><span class="line">trueNode* end = <span class="literal">NULL</span>;<span class="comment">//保存尾结点的值</span></span><br><span class="line">true<span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">truetrueNode* next = cur-&gt;next;</span><br><span class="line">truetrue<span class="keyword">if</span> (cur-&gt;val != val) &#123;</span><br><span class="line">truetruetrue<span class="keyword">if</span> (ret == <span class="literal">NULL</span>) &#123;</span><br><span class="line">truetruetruetruecur-&gt;next = ret;</span><br><span class="line">truetruetruetrueret = cur;</span><br><span class="line">truetruetruetrueend = cur;</span><br><span class="line">truetruetrue&#125;</span><br><span class="line">truetruetrue<span class="keyword">else</span> &#123;</span><br><span class="line">truetruetruetruecur-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">truetruetruetrueend-&gt;next = cur;</span><br><span class="line">truetruetrue&#125;</span><br><span class="line">truetrue&#125;</span><br><span class="line">truetruecur = next;</span><br><span class="line">true&#125;</span><br></pre></td></tr></table></figure><h5 id="3-给定一个带有头结点-head-的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。"><a href="#3-给定一个带有头结点-head-的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。" class="headerlink" title="3.给定一个带有头结点 head 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。"></a>3.给定一个带有头结点 head 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。</h5><p>方案:这里采用快慢指针的方法即快指针走两步慢指针走一步,当快指针走到尾结点时,慢指针恰好在中间结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">middleNode</span><span class="params">(struct ListNode* head)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//设置快慢节点 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">slow</span>,*<span class="title">fast</span>;</span></span><br><span class="line">    <span class="comment">//将快慢节点都指向头节点 </span></span><br><span class="line">trueslow = head;</span><br><span class="line">truefast = head;</span><br><span class="line">true<span class="comment">//当慢节点不为空并且快节点的下一个节点不为空</span></span><br><span class="line">true<span class="comment">//(因为要使用要快节点的下下个节点,所以要确保快节点的下一个节点不为空) </span></span><br><span class="line">true<span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">truetrue<span class="comment">//慢节点移动一次,快节点移动两次 </span></span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">truetrueslow = slow-&gt;next;</span><br><span class="line">truetruefast = fast-&gt;next;</span><br><span class="line">true&#125;</span><br><span class="line">true<span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。"><a href="#4-将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。" class="headerlink" title="4.将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。"></a>4.将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">mergeTwoLists</span><span class="params">(struct ListNode* l1, struct ListNode* l2)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">ret</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">end</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">cur_1</span> = <span class="title">l1</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">cur_2</span> = <span class="title">l2</span>;</span></span><br><span class="line">     <span class="keyword">if</span>(cur_1 == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> cur_1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur_2 == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> cur_2;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">while</span>(cur_1 != <span class="literal">NULL</span> &amp;&amp; cur_2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">       <span class="comment">//如果第一个值小于第二个值进行尾插</span></span><br><span class="line">        <span class="keyword">if</span>(cur_1-&gt;val &lt;= cur_2-&gt;val)&#123;</span><br><span class="line">            <span class="comment">//第一个节点</span></span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                ret=end=cur_1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                end-&gt;next = cur_1;</span><br><span class="line">                end = cur_1;</span><br><span class="line">            &#125;</span><br><span class="line">            cur_1 = cur_1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">       <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(ret == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                ret = end = cur_2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                end-&gt;next = cur_2;</span><br><span class="line">                end = cur_2;</span><br><span class="line">            &#125;</span><br><span class="line">           cur_2 = cur_2-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">      <span class="keyword">if</span>(cur_1 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">           end-&gt;next = cur_1;</span><br><span class="line">       &#125;</span><br><span class="line">      <span class="keyword">if</span>(cur_2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">          end-&gt;next = cur_2;</span><br><span class="line">    &#125;</span><br><span class="line">       <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-输入一个链表，输出该链表中倒数第k个结点。"><a href="#5-输入一个链表，输出该链表中倒数第k个结点。" class="headerlink" title="5.输入一个链表，输出该链表中倒数第k个结点。"></a>5.输入一个链表，输出该链表中倒数第k个结点。</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindKthToTail</span><span class="params">(ListNode* pListHead, <span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode* front = pListHead;</span><br><span class="line">        ListNode* Later = pListHead;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//统计结点个数</span></span><br><span class="line">        <span class="comment">//移动k个结点</span></span><br><span class="line">        <span class="keyword">for</span>(;i &lt; k &amp;&amp; front != <span class="literal">NULL</span>;++i)&#123;</span><br><span class="line">           front=front-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k &gt; i)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">NULL</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(front != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            Later= Later-&gt;next;</span><br><span class="line">            front = front-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Later;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="编写代码，以给定值x为基准将链表分割成两部分，所有小于x的结点排在大于或等于x的结点之前"><a href="#编写代码，以给定值x为基准将链表分割成两部分，所有小于x的结点排在大于或等于x的结点之前" class="headerlink" title="编写代码，以给定值x为基准将链表分割成两部分，所有小于x的结点排在大于或等于x的结点之前"></a>编写代码，以给定值x为基准将链表分割成两部分，所有小于x的结点排在大于或等于x的结点之前</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Partition</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* pHead, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">         ListNode* big = <span class="literal">NULL</span>;</span><br><span class="line">         ListNode* big_end = <span class="literal">NULL</span>;</span><br><span class="line">         ListNode* small = <span class="literal">NULL</span>;</span><br><span class="line">         ListNode* small_end = <span class="literal">NULL</span>;</span><br><span class="line">         ListNode* cur = pHead;</span><br><span class="line">         ListNode* ret = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val &gt;= x)&#123;</span><br><span class="line">                <span class="keyword">if</span>(big == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    big = big_end = cur;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    big_end-&gt;next = cur;</span><br><span class="line">                        big_end = cur;</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val &lt; x)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(small == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    ret =small = small_end = cur;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    small_end-&gt;next = cur;</span><br><span class="line">                       small_end = cur;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">             cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(small == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            big_end-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> big;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(big == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            small_end-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> small;</span><br><span class="line">        &#125;</span><br><span class="line">             small_end-&gt;next = big;</span><br><span class="line">             big_end-&gt;next =<span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="6-在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。"><a href="#6-在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。" class="headerlink" title="6.在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。"></a>6.在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       ListNode*  Front = pHead;</span><br><span class="line">       ListNode*  Later = pHead-&gt;next;</span><br><span class="line">       ListNode* head = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">       ListNode*  prev = head;</span><br><span class="line">        head-&gt;next = pHead;</span><br><span class="line">        <span class="keyword">while</span>( Later != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span>(Front-&gt;val != Later-&gt;val)&#123;</span><br><span class="line">                prev = Front;</span><br><span class="line">                Front = Later;</span><br><span class="line">                <span class="keyword">if</span>(Later != <span class="literal">NULL</span>)</span><br><span class="line">                Later = Later-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(Later != <span class="literal">NULL</span> &amp;&amp; Front-&gt;val == Later-&gt;val)&#123;</span><br><span class="line">                    Later = Later-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                prev-&gt;next = Later;</span><br><span class="line">                Front = Later;</span><br><span class="line">                <span class="keyword">if</span>(Later != <span class="literal">NULL</span>)</span><br><span class="line">                Later = Later-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。要求返回这个链表的深度拷贝。"><a href="#给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。要求返回这个链表的深度拷贝。" class="headerlink" title="给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。要求返回这个链表的深度拷贝。"></a>给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。要求返回这个链表的深度拷贝。</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node* ret = <span class="literal">NULL</span>;</span><br><span class="line">        Node* end = <span class="literal">NULL</span>;</span><br><span class="line">        Node* cur = head;</span><br><span class="line">        <span class="comment">//复制val的值</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">NULL</span>)&#123;</span><br><span class="line">   Node* Newnode = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">      Newnode-&gt;val = cur-&gt;val;</span><br><span class="line">           Node* Next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = Newnode;</span><br><span class="line">            Newnode-&gt;next = Next;</span><br><span class="line">              cur = Newnode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="comment">//复制random</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">//如果Random不为空复制 为空继续复制下一个结点</span></span><br><span class="line">           <span class="keyword">if</span>(cur-&gt;random != <span class="literal">NULL</span>)&#123;</span><br><span class="line">               cur-&gt;next-&gt;random = cur-&gt;random-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">            cur  = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拆开链表</span></span><br><span class="line">        cur = head;</span><br><span class="line">        ret = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">//将两个链表拆开</span></span><br><span class="line">           Node *node = cur-&gt;next;</span><br><span class="line"></span><br><span class="line">truetruecur-&gt;next = node-&gt;next;</span><br><span class="line">truetrue<span class="keyword">if</span> (node-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">truetruetruenode-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">truetrue&#125;</span><br><span class="line">truetrue</span><br><span class="line">truetruecur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="辨析辨析循环终止条件cur-NULL-cur-gt-next-NULL"><a href="#辨析辨析循环终止条件cur-NULL-cur-gt-next-NULL" class="headerlink" title="辨析辨析循环终止条件cur != NULL,cur-&gt;next != NULL"></a>辨析辨析循环终止条件cur != NULL,cur-&gt;next != NULL</h4><p>cur != NULL是当前结点不为空就是最后一个结点,而cur-&gt;next != NULL当前结点的下一个结点不为空,是倒数第二个结点,在尾删这种情况下,我们需要找到最后一个结点的地址这是个单向链表的情况下我们需要找到他的前一个地址所以循环终止的条件是cur-&gt;next != NULL.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基础数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络层</title>
      <link href="/2019/08/21/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
      <url>/2019/08/21/%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="网络层功能："><a href="#网络层功能：" class="headerlink" title="网络层功能："></a>网络层功能：</h3><p><strong>路由选择与分组转发</strong>：找到传输最佳路径</p><p><strong>异构网络互联</strong>：组织各种网络形成英特网</p><p><strong>拥塞控制</strong>：若所有结点都来不及接受分组，而要丢弃大量分组的话，网络就处于拥塞状态。</p><p>解决办法WAY1：开环控制（静）WAY2：闭环控制（动态）</p><h3 id="数据交换方式"><a href="#数据交换方式" class="headerlink" title="数据交换方式"></a>数据交换方式</h3><h5 id="电路交换："><a href="#电路交换：" class="headerlink" title="电路交换："></a>电路交换：</h5><h5 id="报文交换："><a href="#报文交换：" class="headerlink" title="报文交换："></a>报文交换：</h5><h5 id="分组交换："><a href="#分组交换：" class="headerlink" title="分组交换："></a>分组交换：</h5><h3 id="IP数据报格式"><a href="#IP数据报格式" class="headerlink" title="IP数据报格式"></a>IP数据报格式</h3><p><img src="D:\MyBlog\source\images\IP数据报格式.jpg" alt=""></p><p>字段解释：</p><p>首部长度：单位是4B，最小为5；</p><p>区分服务：指示期望获得那种类型的服务</p><p>总长度：首部+数据，单位是1B</p><p>生存时间（TTL）：IP分组的保质期，经过一个路由器计数-1，为0则丢弃。</p><p>协议：传输层协议对应字段，TCP（6），UDP（17）</p><p>首部检验和：只检验首部</p><p>可选字段：0~40B，用来支持排错测量以及其他安全功能</p><p>填充字段：全0，数据报补成4B的整数倍</p><h4 id="IP数据报的分片："><a href="#IP数据报的分片：" class="headerlink" title="IP数据报的分片："></a>IP数据报的分片：</h4><p>MTU：链路层数据帧可以封装的上限以太网为1500字节，如果传输的数据大于MTU值，就要分片</p><p><img src="D:\MyBlog\source\images\IP数据报分片.png" alt=""></p><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>IP地址分为两个部分： 网络号 + 主机号 </p><p>网络号: 保证相互连接的两个网段具有不同的标识; </p><p>主机号: 同一网段内, 主机之间具有相同的网络号, 但是必须有不同的主机号; </p><p>不同的子网其实就是把网络号相同的主机放到一起。如果在子网中新增一台主机, 则这台主机的网络号和这个子网的网络号一致, 但是主机号必须不能和子网中的其他主机重复. </p><p>通过合理设置主机号和网络号, 就可以保证在相互连接的网络中, 每台主机的IP地址都不相同. 手动管理子网内的IP, 是一个相当麻烦的事情. 有一种技术叫做<strong>DHCP</strong>, 能够自动的给子网内新增主机节点分配IP地址, 避免了手动管理IP的不便. 一般的路由器都带有DHCP功能. 因此路由器也可以看做一个DHCP服务器.  </p><h4 id="IP地址划分"><a href="#IP地址划分" class="headerlink" title="IP地址划分"></a>IP地址划分</h4><p>过去曾经提出一种划分网络号和主机号的方案, 把所有IP 地址分为五类</p><p>A类 0.0.0.0到127.255.255.255  </p><p>B类 128.0.0.0到191.255.255.255  </p><p>C类 192.0.0.0到223.255.255.255  </p><p>D类 224.0.0.0到239.255.255.255  </p><p>E类 240.0.0.0到247.255.255.255 </p><p><img src="D:\MyBlog\source\images\IP地址分类.png" alt=""></p><p>随着Internet的飞速发展,这种划分方案的局限性很快显现出来,大多数组织都申请B类网络地址, 导致B类地址很快就 分配完了, 而A类却浪费了大量地址; 例如, 申请了一个B类地址, 理论上一个子网内能允许6万5千多个主机. A类地址的子网内的主机数更多.  然而实际网络架设中, 不会存在一个子网内有这么多的情况. 因此大量的IP地址都被浪费掉了.  针对这种情况提出了新的划分方案, 称为<strong>CIDR</strong>(Classless Interdomain Routing): 引入一个额外的子网掩码(subnet mask)来区分网络号和主机号; </p><ul><li><p>子网掩码也是一个32位的正整数. 通常用一串 “0” 来结尾; <strong>子网掩码就是网络号全为1，主机号全0</strong>；</p></li><li><p>将IP地址和子网掩码进行 “按位与” 操作, 得到的结果就是网络号; </p></li><li>网络号和主机号的划分与这个IP地址是A类、B类还是C类无关;</li></ul><h4 id="CIDR技术"><a href="#CIDR技术" class="headerlink" title="CIDR技术"></a>CIDR技术</h4><ul><li>CIDR 消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，因而可以更加有效地分配 IPv4 的地址间。</li><li>CIDR使用各种长度的“网络前缀”(network-prefix)来代替分类地址中的网络号和子网号。</li><li>IP 地址从三级编址（使用子网掩码）又回到了两级编址。</li><li>128.14.32.0/20表示的地址块共有212个地址，因为斜线后面的20是网络前缀的比特数，所以主机号的比特12</li></ul><h4 id="路由聚合"><a href="#路由聚合" class="headerlink" title="路由聚合"></a>路由聚合</h4><ul><li>一个 CIDR 地址块可以表示很多地址，这种地址的聚合常称为路由聚合/超网(supernetting)。它使得路由表中的一个项目可以表示很多个原来传统分类地址的路由。</li><li>路由聚合也称为CIDR，虽然不使用子网了，但仍然使用“掩码”这一名词（但不叫子网掩码）。</li></ul><h4 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h4><ul><li>为了获得子网标识，需要从主机位中借出若干位，指定作为子网络标识。</li><li>必须为主机位中的高n位。 </li><li>从主机位中所借的子网位的位数n取决于子网络的规模。</li><li>n 的最小值为 2（为什么不是1？）</li><li>n的最大值是多少？只要能保证有2位的主机标识位</li></ul><p><strong>主机号全0：为本机，主机号全1：为广播</strong>。</p><h4 id="网络地址转换NAT技术"><a href="#网络地址转换NAT技术" class="headerlink" title="网络地址转换NAT技术"></a>网络地址转换NAT技术</h4><p>网络地址转换NAT：在专用网连接到因特网的路由器上安装NAT，安装了NAT软件的路由器叫NAT路由器，他至少有一个有效的外部全球外部IP地址。</p><h5 id="NAT转换表："><a href="#NAT转换表：" class="headerlink" title="NAT转换表："></a>NAT转换表：</h5><p><img src="D:\MyBlog\source\images\NAT转换表.png" alt=""></p><h4 id="路由器转发分组的算法：最长前缀"><a href="#路由器转发分组的算法：最长前缀" class="headerlink" title="路由器转发分组的算法：最长前缀"></a>路由器转发分组的算法：最长前缀</h4><p><strong>路由表</strong>：目的网络的地址，目的网络子网掩码，下一跳地址。</p><ol><li>提取目的IP地址</li><li>是不是可以之间交付</li><li>特定主机路由</li><li>检测路由表有没有合适路径</li><li>默认路由0.0.0.0</li><li>丢弃，报告转发分组出错</li></ol><h5 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h5><p>ARP协议：完成主机或路由器IP地址到MAC地址的映射。（解决下一跳）</p><p>ARP协议使用过程：</p><p><img src="D:\MyBlog\source\images\ARP.png" alt=""></p><p>ARP协议四个场景：</p><p><img src="D:\MyBlog\source\images\ARP应用场景.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>传输层</title>
      <link href="/2019/08/20/%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
      <url>/2019/08/20/%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p><strong>只有主机才有的层次</strong></p><h3 id="传输层的功能："><a href="#传输层的功能：" class="headerlink" title="传输层的功能："></a>传输层的功能：</h3><ul><li>传输层提供进程和进程的逻辑通信。</li><li>复用（应用层所有数据都可以通过传输层传再传输到网络层）和分用（收到数据交付给指定进程）；</li><li>传输层（TCP）对收到的报文进行差错检测（传输层和网络层实现可靠传输）</li></ul><h3 id="传输层的寻址与端口"><a href="#传输层的寻址与端口" class="headerlink" title="传输层的寻址与端口"></a>传输层的寻址与端口</h3><p>端口（逻辑端口）：传输层的SAP（服务访问点）标识主机中的进程，只有本地意义</p><p>端口号：16bit，标识65535个端口号。</p><p><strong>端口号范围</strong>:  0~65535    0~1023不推荐使用,在一台主机上唯一标识一个进程</p><p><strong>0~1023被知名协议使用:</strong></p><ol><li>ssh服务器, 使用22端口</li><li>ftp服务器, 使用21端口 </li><li>telnet服务器, 使用23端口 </li><li>http服务器, 使用80端口 </li><li>https服务器, 使用443</li></ol><p><strong>功能</strong>: 操作系统使用网卡接收数据,通过端口号就可以知道将数据放到那个socket缓冲区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个端口号只能有一个进程使用,一个进程可以使用多个端口号</span><br></pre></td></tr></table></figure><p><strong>五元组</strong>:一条网络数据包含的五条信息:源IP+源端口+目的IP+目的端口+协议</p><a id="more"></a><h3 id="主机上网络状态的查看"><a href="#主机上网络状态的查看" class="headerlink" title="主机上网络状态的查看"></a>主机上网络状态的查看</h3><p><strong>netstat</strong>:查看网络状态 </p><p><strong>常用选项</strong></p><ul><li>n 拒绝显示别名，能显示数字的全部转化成数字</li><li>l 仅列出有在 Listen (监听) 的服務状态 </li><li>p 显示建立相关链接的程序名 </li><li>t (tcp)仅显示tcp相关选项 </li><li>u (udp)仅显示udp相关选项 </li><li>a (all)显示所有选项，默认不显示LISTEN相关 </li></ul><h3 id="UDP（用户数据报）"><a href="#UDP（用户数据报）" class="headerlink" title="UDP（用户数据报）"></a>UDP（用户数据报）</h3><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><h4 id="特点-无连接-不可靠-面向数据报"><a href="#特点-无连接-不可靠-面向数据报" class="headerlink" title="特点:无连接,不可靠,面向数据报"></a><strong>特点:</strong>无连接,不可靠,面向数据报</h4><p><strong>UDP只在IP数据报上添加了很少的功能，复用分用差错检测</strong></p><ul><li>无连接: 知道对端的IP和端口号就直接进行传输, 不需要建立连接; </li><li>不可靠: 没有确认机制, 没有重传机制; 如果因为网络故障该段无法发到对方, UDP协议层也不会给应用层 返回任何错误信息; </li><li>面向数据报: 不能够灵活的控制读写数据的次数和数量数据整条收发,灵活性低,不会产生黏包</li></ul><p><img src="D:\MyBlog\source\images\udp面向报文.png" alt=""></p><h3 id="UDP协议格式"><a href="#UDP协议格式" class="headerlink" title="UDP协议格式"></a>UDP协议格式</h3><p><img src="D:\MyBlog\source\images\UDP首部格式.jpg" alt=""></p><p>源端口号：不需要收到回复则不需要</p><p>UDP校验和：如果出错则丢弃，分用时找不到端口对应的进程就丢弃报文发送ICMP（端口不可达）差错报告报文</p><p><strong>udp协议包含字段</strong></p><p><img src="D:\MyBlog\source\images\UDP格式.png" alt=""></p><h4 id="udp检验和原理"><a href="#udp检验和原理" class="headerlink" title="udp检验和原理"></a>udp检验和原理</h4><p><img src="D:\MyBlog\source\images\udp.jpg" alt=""></p><p><strong>伪首部</strong>：（伪IP首部）IP数据包数据首部协议字段+源IP地址+目的IP地址，只在计算校验和时出现。</p><p><img src="D:\MyBlog\source\images\udp校验.png" alt=""></p><h4 id="UDP的缓冲区"><a href="#UDP的缓冲区" class="headerlink" title="UDP的缓冲区"></a>UDP的缓冲区</h4><p>UDP没有真正意义上的 发送缓冲区. 调用sendto会直接交给内核, 由内核将数据传给网络层协议进行后续的传输动作; UDP具有接收缓冲区. 但是这个接收缓冲区不能保证收到的UDP报的顺序和发送UDP报的顺序一致; 如果 缓冲区满了, 再到达的UDP数据就会被丢弃; UDP的socket既能读, 也能写, 这个概念叫做 全双工</p><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><h4 id="TCP特点"><a href="#TCP特点" class="headerlink" title="TCP特点:"></a>TCP特点:</h4><p>面向连接（虚连接），面向字节流，可靠传输，全双工通信</p><h4 id="TCP报文首部格式："><a href="#TCP报文首部格式：" class="headerlink" title="TCP报文首部格式："></a>TCP报文首部格式：</h4><p><img src="D:\MyBlog\source\images\TCP.jpg" alt=""></p><p>1.源端口和目的端口，各占2个字节。</p><p>2.序号位：占4个字节，序号范围为0到2的32次方-1，序号增加到2的32次方-1之后，下一个序号变为0，在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。首部中的序号字段值指的是本报文段所发送的数据的第一个字节的序号。可对4GB的数据进行编号。在一般情况下可保证当序号重复使用时，旧序号的数据早已通过网络到达终点了。</p><p>3.确认号：占4字节，是期望收到对方下一个报文段的第一个数据字节的序号。记住：若确认号是N，则表明：到序号N-1为止的所有数据都已正确收到。</p><p>4.数据偏移：占4位，它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远，这个字段实际上是指出TCP报文段的首部长度。</p><p>6.保留：占6位。保留为今后使用，目前置为0</p><p>7.选项：长度可变，最长可达40字节，当没有选项时，TCP的首部长度是20字节。</p><p>8.最大报文段长度MSS，MSS是指每一个TCP报文段中的数据字段的最大长度。</p><p>9.窗口，占2个字节，窗口指的是发送本报文段的一方的接收窗口，不是自己的发送窗口，告诉对方：从本报文段      首部中的确认号算起，接收方目前允许对方发送的数据量。窗口值作为接受方让发送方设置其发送窗口的依据。</p><p>10.校验和，占2字节。校验和字段检验的范围包括首部和数据这两部分。</p><p>11.紧急指针：占2个字节，紧急指针仅在URG=1时才有意义，它指出本报文段中的紧急数据的字节数。当所有紧急数据处理完毕时，TCP就告诉应用程序恢复到正常操作。值得注意的是，即使窗口为0时也可发送紧急数据。</p><p><strong>控制位</strong>：</p><ul><li>紧急URG（URGent）：当URG=1时，表明紧急字段有效，告诉系统此报文中有紧急数据，应尽快传送。于是发送方TCP就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。这时要与首部中紧急指针字段配合使用。</li><li>确认ACK（ACKnowlegment）仅当ACK=1时确认号字段才有效，TCP规定，连接建立后所有传送的报文段都必须把ACK置1.</li><li>推送PUSH（PUSH）：当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应。在这种情况下，TCP就可以使用推送操作。</li><li>复位RST（RESET）:当RST=1时，表明TCP连接中出现严重错误，必须释放连接，然后再重新建立运输连接。拒绝非法报文段，拒绝连接。</li><li>同步SYN，在连接建立时用来同步序号，当SYN=1而ACK=0时，表明这是一个连接请求报文段。对方若同意时，则应在响应的报文段中使SYN=1和ACK=1，因此，SYN置1就表示这是一个连接请求或连接接受报文。</li><li>终止FIN，用来释放一个连接，当FIN=1时，表示此报文段的发送方的数据已发送完毕，并要求释放运输连接。</li></ul><h4 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理:"></a>连接管理:</h4><h5 id="TCP连接建立"><a href="#TCP连接建立" class="headerlink" title="TCP连接建立"></a>TCP连接建立</h5><p><img src="D:\MyBlog\source\images\TCP连接建立.png" alt=""></p><h5 id="TCP连接释放："><a href="#TCP连接释放：" class="headerlink" title="TCP连接释放："></a>TCP连接释放：</h5><p><img src="D:\MyBlog\source\images\TCP连接释放png.png" alt=""></p><p><img src="D:\MyBlog\source\images\tcp连接管理.png" alt=""></p><h4 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h4><ul><li>TCP协议规定,主动关闭连接的一方要处于TIME_ WAIT状态,等待两个MSL(maximum segment lifetime) 的时间后才能回到CLOSED状态. 。</li><li>MSL在RFC1122中规定为两分钟,但是各操作系统的实现不同, 在Centos7上默认配置的值是60s; </li><li>可以通过 cat /proc/sys/net/ipv4/tcp_fin_timeout 查看msl的值; </li></ul><h4 id="TIME-WAIT的必要性"><a href="#TIME-WAIT的必要性" class="headerlink" title="TIME_WAIT的必要性:"></a>TIME_WAIT的必要性:</h4><ol><li>如果没有TIME_WAIT,最后一个ack丢失，被动关闭方重发FIN， 主动关闭方没有等待直接关闭，假如启动服务又使用相同的端口，有可能收到上一个连接重发的FIN，对新连接造成影响。</li><li>若新的客户端使用相同的端口信息，向服务端发送SYN请求但是服务端没有收到SYN最后一个ACK处于LAST_ACK状态，收到SYN判定状态错误，回复RST报文重置连接，对新连接造成影响所以主动关闭方发送最后一个ack之后需要等待：两个MSL</li></ol><h5 id="等待时间是2MSL的原因"><a href="#等待时间是2MSL的原因" class="headerlink" title="等待时间是2MSL的原因"></a>等待时间是2MSL的原因</h5><ul><li>等待ack丢失导致对端重传的FIN包</li><li>等待网络中所有双方延迟的报文消失</li></ul><p>MSL是TCP报文的最大生存时间, 因此TIME_WAIT持续存在2MSL的话 就能保证在两个传输方向上的尚未被接收或迟到的报文段都已经消失(否则服务器立刻重启, 可能会收到 来自上一个进程的迟到的数据, 但是这种数据很可能是错误的); 同时也是在理论上保证最后一个报文可靠到达(假设最后一个ACK丢失, 那么服务器会再重发一个FIN. 这   时虽然客户端的进程不在了, 但是TCP连接还在, 仍然可以重发LAST_ACK); </p><h4 id="可靠传输："><a href="#可靠传输：" class="headerlink" title="可靠传输："></a>可靠传输：</h4><p><strong>确认和重传 拥塞控制，流量控制，数据校验，和数据合理的分片，连接管理</strong>保证了可靠传输。</p><p>有序：协议字段中的确认序号和序号，    </p><h4 id="确认："><a href="#确认：" class="headerlink" title="确认："></a>确认：</h4><p><strong>确认应答</strong>：每一个ACK都带有对应的确认序列号, 告诉发送者, 我已经收到了哪些数据; 下一次你从哪里开发送</p><p>刚才我们讨论了确认应答策略, 对每一个发送的数据段, 都要给一个ACK确认应答. 收到ACK后再发送下一个数据段. </p><p>这样做有一个比较大的缺点, 就是性能较差. 尤其是数据往返的时间较长的时候</p><h4 id="重传："><a href="#重传：" class="headerlink" title="重传："></a>重传：</h4><h5 id="超时重传：RTTs（加权平均往返时间）"><a href="#超时重传：RTTs（加权平均往返时间）" class="headerlink" title="超时重传：RTTs（加权平均往返时间）"></a>超时重传：RTTs（加权平均往返时间）</h5><h5 id="快速重传：冗余ACK"><a href="#快速重传：冗余ACK" class="headerlink" title="快速重传：冗余ACK"></a>快速重传：冗余ACK</h5><p>接收端每条数据都要回复，要按序回复，即使后一条到了但是前一条没有到达也不回复后到的数据的ACK，只有上一条回复之后才回复，所以如果发送端收到了第二条的回复说明第一条数据一定到了，即使第一条的回复丢失了也不会重传，当数据连续发送，数据丢失时，接收端连续发送三次（防止网络时延）重传请求，当发送端接收到了第三次重传请求，则会对这条数据重传</p><h4 id="流量控制："><a href="#流量控制：" class="headerlink" title="流量控制："></a>流量控制：</h4><p>接收端处理数据的速度是有限的. 如果发送端发的太快, 导致接收端的缓冲区被打满, 这个时候如果发送端继续发送, 就会造成丢包, 继而引起丢包重传等等一系列连锁反应.  因此TCP支持根据接收端的处理能力, 来决定发送端的发送速度. 这个机制就叫流量控制; 接收端将自己可以接收的缓冲区大小放入 TCP 首部中的 “窗口大小” 字段, 通过ACK端通知发送端; 窗口大小字段越大, 说明网络的吞吐量越高; 接收端一旦发现自己的缓冲区快满了, 就会将窗口大小设置成一个更小的值通知给发送端; 发送端接受到这个窗口之后, 就会减慢自己的发送速度; 如果接收端缓冲区满了, 就会将窗口置为0; 这时发送方不再发送数据, 但是需要定期发送一个窗口探测数 据段, 使接收端把窗口大小告诉发送端。</p><p><strong>因为可靠传输，牺牲了部分新能；因此引入了几种机制提高性能</strong></p><h5 id="滑动窗口机制：连续发送多条数据等待回复"><a href="#滑动窗口机制：连续发送多条数据等待回复" class="headerlink" title="滑动窗口机制：连续发送多条数据等待回复"></a>滑动窗口机制：连续发送多条数据等待回复</h5><p>通信双方通过协议中的窗口字段，来协商能够一次发送的最多数据，然后连续发送多条数据；在socket当中使用两个指针维护窗口后沿(起始位置)和前沿(发送的结束位置)。</p><pre><code>发送端：若窗口中后沿数据没有接收到ack确认，后沿就不能向前移动，数据就不能从缓冲区移除，接收到ack确认后窗口，前后沿向后移动。接收端：当接收数据的时候，如果没有接收到第一条数据，则后沿不能移动，只有接收到数据之后，后沿才会向前移动</code></pre><h5 id="拥塞窗口机制：慢启动，快增长。"><a href="#拥塞窗口机制：慢启动，快增长。" class="headerlink" title="拥塞窗口机制：慢启动，快增长。"></a>拥塞窗口机制：慢启动，快增长。</h5><h5 id="延迟应答机制：尽可能保持窗口大小，保持网络吞吐率"><a href="#延迟应答机制：尽可能保持窗口大小，保持网络吞吐率" class="headerlink" title="延迟应答机制：尽可能保持窗口大小，保持网络吞吐率"></a>延迟应答机制：尽可能保持窗口大小，保持网络吞吐率</h5><p>接收方接收数据后不立刻进行确认回复，而是等待一段时间，因为这段延迟的时间内，有可能用户recv将缓冲区中的数据取走，窗口就尽可能地保证最大窗口，保证传输地吞吐量。尽可能地保证滑动窗口地性能。</p><h5 id="捎带应答机制：尽量减少不必要的确认应答包"><a href="#捎带应答机制：尽量减少不必要的确认应答包" class="headerlink" title="捎带应答机制：尽量减少不必要的确认应答包"></a>捎带应答机制：尽量减少不必要的确认应答包</h5><p>接收方对每一条数据地确认回复都需要发送一个TCP数据报；但是空报头地传输会降低性能因此会考虑在即将要发送地数据报中包含有确认信息(可以少发一个确认的空报头)</p><h4 id="面向字节流"><a href="#面向字节流" class="headerlink" title="面向字节流"></a>面向字节流</h4><p>创建一个TCP的socket, 同时在内核中创建一个 <strong>发送缓冲区</strong> 和一个 <strong>接收缓冲区</strong>; </p><ul><li>调用write时, 数据会先写入发送缓冲区中; </li><li>如果发送的字节数太长, 会被拆分成多个TCP的数据包发出; </li><li>如果发送的字节数太短, 就会先在缓冲区里等待, 等到缓冲区长度差不多了, 或者其他合适的时机发送出 去; </li><li>接收数据的时候, 数据也是从网卡驱动程序到达内核的接收缓冲区; </li><li>然后应用程序可以调用read从接收缓冲区拿数据; </li><li>另一方面, TCP的一个连接, 既有发送缓冲区, 也有接收缓冲区, 那么对于这一个连接, 既可以读数据, 也可 </li></ul><p>​       以写数据. 这个概念叫做 <strong>全双工</strong> </p><p>由于缓冲区的存在, TCP程序的读和写不需要一一匹配, 例如: </p><ul><li>写100个字节数据时, 可以调用一次write写100个字节, 也可以调用100次write, 每次写一个字节; </li><li>读100个字节数据时, 也完全不需要考虑写的时候是怎么写的, 既可以一次read 100个字节, 也可以一次 </li></ul><p>​        read一个字节, 重复100次;</p><p><strong>TCP的粘包问题：</strong>数据没有边界</p><h4 id="TCP异常情况"><a href="#TCP异常情况" class="headerlink" title="TCP异常情况"></a>TCP异常情况</h4><ul><li>进程终止: 进程终止会释放文件描述符, 仍然可以发送FIN. 和正常关闭没有什么区别. </li><li>机器重启: 和进程终止的情况相同. </li><li>机器掉电/网线断开: 接收端认为连接还在, 一旦接收端有写入操作, 接收端发现连接已经不在了, 就会进行reset. 即 使没有写入操作, TCP自己也内置了一个保活定时器, 会定期询问对方是否还在. 如果对方不在, 也会把连接释放. 另外, 应用层的某些协议, 也有一些这样的检测机制. 例如HTTP长连接中, 也会定期检测对方的状态. 例如QQ, 在QQ 断线之后, 也会定期尝试重新连接。</li></ul><h5 id="为什么握手是三次，挥手是四次？"><a href="#为什么握手是三次，挥手是四次？" class="headerlink" title="为什么握手是三次，挥手是四次？"></a>为什么握手是三次，挥手是四次？</h5><p><strong>在握手过程中，为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</strong></p><p>当客户端发出的第一个连接请求报文段并没有丢失，而是在网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达服务端。本来这是一个早已失效的报文段。但是服务端收到此失效的连接请求报文段之后，就误认为是客户端再次发出的一个新的连接请求。于是就向客户端发出确认报文段，同意建立连接。假设我们不采用“三次握手”，那么服务端发出确认，新的连接就建立成功了。由于现在client并没有发出建立连接的请求，因此不会理睬服务端的确认，也不会像服务端发送数据。但是服务端却以为新的建立已经完成，一直等待消息发送到来。这样，服务端的数据很多数据被白白浪费了。采用“三次握手”可以有效的避免这种情况。客户端不会向服务端的确认发出确认，服务端由于收不到确认，就认为客户端没有建立连接。</p><p><strong>所以，三次握手也可以看作为了防止服务端的一直等待而浪费资源。</strong></p><p>挥手过程是一个相互的确认过程，首先我们都已知TCP的连接是全双工的，既可以发送也可以接收。那么当双方都确认自己没有数据可以发送，并且都互相表示双方知道对方没有数据之后，那么连接也就断开了。</p><p>假设挥手在第三次结束。客户端发送了一个FIN就打算断开连接。那么客户端又如何知道服务端想要断开连接？有可能客户端刚发送完了数据，但是服务端并没有。服务端打算发完了剩下的数据在跟客户端”拜拜“。</p><p>此时就出现了矛盾。所以挥手有第四次来进行双发的确认。确认双方的工作都做完了。</p><h5 id="SYN泛洪攻击"><a href="#SYN泛洪攻击" class="headerlink" title="SYN泛洪攻击"></a>SYN泛洪攻击</h5><p><strong>SYN泛洪攻击利用TCP三次握手协议的缺陷，向目标主机发送大量的伪造源地址的SYN连接请求，使得被攻击方资源耗尽，从而不能够为正常用户提供服务。</strong></p><p>在TCP协议中被称为三次握手（Three-way Handshake）的连接过程中，如果一个用户向服务器发送了SYN报文，服务器又发出 SYN+ACK 应答报文后<strong>未收到客户端的 ACK 报文</strong>，这种情况下服务器端会再次发送SYN+ACK给客户端，并等待一段时间后丢弃这个未完成的连接，这段时间的长度称为<strong>SYN Timeout</strong>，一般来说这个时间是分钟的数量级。</p><p>SYN 泛洪攻击所做的就是利用这个SYN Timeout和TCP/IP协议族中的另一个漏洞: 报文传输过程中对报文的源 IP 地址完全信任进行攻击。SYN 泛洪攻击通过发送大量的伪造 TCP 链接报文而造成大量的 TCP 半连接,服务器端将为了维护这样一个庞大的半连接列表而消耗非常多的资源。这样服务器端将忙于处理攻击者伪造的TCP连接请求而无法处理正常连接请求,甚至会导致堆栈的溢出崩溃</p><p>造成SYN洪泛攻击最主要的原因是TCP/IP协议的脆弱性。TCP/IP是一个开放的协议平台，它将越来越多的网络连接在一起，它基于的对象是可信用户群，所以缺少一些必要的安全机制，带来很大的安全威胁。例如常见的IP欺骗、TCP连接的建立、ICMP数据包的发送都存在巨大的安全隐患，给SYN洪泛攻击带来可乘之机。</p><h6 id="防范方法"><a href="#防范方法" class="headerlink" title="防范方法"></a>防范方法</h6><p>1、<strong>缩短SYN Timeout时间</strong>，短时间内收不到客户端的ACK回复报文直接丢弃，防止被攻击</p><p>2、<strong>设置SYN cookie</strong>，给每一个请求连接的IP地址分配一个cookie，如果短时间内连续受到某个IP的重复SYN文，认定是受到了攻击，以后从这个IP地址来的包会被丢弃。</p><p>3、<strong>设置SYN可疑队列</strong></p><p>4、<strong>使用防火墙</strong></p><p>推荐博客链接：<a href="https://blog.csdn.net/justenjoyitpy/article/details/78151239" target="_blank" rel="noopener">https://blog.csdn.net/justenjoyitpy/article/details/78151239</a></p><h5 id="若服务端出现了大量的TIME-WAIT连接，为什么？如何解决？"><a href="#若服务端出现了大量的TIME-WAIT连接，为什么？如何解决？" class="headerlink" title="若服务端出现了大量的TIME_WAIT连接，为什么？如何解决？"></a>若服务端出现了大量的TIME_WAIT连接，为什么？如何解决？</h5><p>这种情况比较常见，一些爬虫服务器或者WEB服务器（如果网管在安装的时候没有做内核参数优化的话）上经常会遇到这个问题，在四次的挥手过程中我们已经可以了解TIME_WAIT状态的出现情况。</p><p>1、防止上一次连接的包迷路后重新出现，影响新连接，所以等待被动方发来的FIN包</p><p>2、可靠的关闭TCP连接。在主动方发送的最后一个ACK，有可能丢失，这时被动方会重新发FIN包，如果这时主动方处于CLOSED状态，就会响应RST而不是ACK。所以主动方要处于TIME_WAIT，而不能是CLOSED。</p><p><strong>解决的方案就是让服务器能够快速回收和重用那些TIME_WAIT资源</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>socket-UDP</title>
      <link href="/2019/08/19/socket-UDP/"/>
      <url>/2019/08/19/socket-UDP/</url>
      
        <content type="html"><![CDATA[<h1 id="Socket网络编程—-UDP"><a href="#Socket网络编程—-UDP" class="headerlink" title="Socket网络编程—-UDP"></a>Socket网络编程—-UDP</h1><h2 id="socket编程：在网络的传输层编程"><a href="#socket编程：在网络的传输层编程" class="headerlink" title="socket编程：在网络的传输层编程"></a>socket编程：在网络的传输层编程</h2><h3 id="UDP编程的基本流程"><a href="#UDP编程的基本流程" class="headerlink" title="UDP编程的基本流程"></a>UDP编程的基本流程</h3><p><img src="D:\MyBlog\source\images\套接字流程.png" alt=""></p><a id="more"></a><h3 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h3><p>网络字节序:由于传输层TCP和UDP协议在网络传输时是采用大端字节序（低地旨存高位），不管这个主机是大端机还是小端机，在传输层都默认采用大端字节序，如果主机是小端机那么就应该转换字节序：Linux库中提供了如下几个函数：</p><h3 id="函数接口："><a href="#函数接口：" class="headerlink" title="函数接口："></a>函数接口：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 socket 文件描述符 (TCP/UDP, 客户端 + 服务器) </span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"> 参数：</span><br><span class="line"> domain：地址域</span><br><span class="line"> AF_INET:IPV4网路协议地址域</span><br><span class="line"> type：套接字类型</span><br><span class="line"> SOCK_STREAM  流式套接字，默认协议TCP不支持UDP</span><br><span class="line"> SOCK_DGRAM   数据报套接字 默认UDP，不支持TCP</span><br><span class="line"> protocol：协议类型</span><br><span class="line"> <span class="number">0</span>：使用套接字默认协议</span><br><span class="line"> <span class="number">6</span>/IPPROTO_TCP tcp协议</span><br><span class="line"> <span class="number">17</span>/IPPROTO_TCP UDP协议</span><br><span class="line"> 返回值：</span><br><span class="line"> 套接字操作句柄文件描述符</span><br><span class="line"> 失败<span class="number">-1</span>；</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定端口号 (TCP/UDP, 服务器)      </span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> socket, <span class="keyword">const</span> struct sockaddr *address,  </span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">socklen_t</span> address_len)</span></span>;</span><br><span class="line">  参数：</span><br><span class="line">  sockfd：   创建套接字返回的描述符</span><br><span class="line">  addr：     地址信息</span><br><span class="line">  addrlen    地址信息长度</span><br><span class="line">  返回值      失败返回<span class="number">-1</span>成功<span class="number">0</span></span><br><span class="line"> <span class="comment">//接受数据</span></span><br><span class="line">  <span class="keyword">ssize_t</span> recvfrom(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span><br><span class="line">                        struct sockaddr *src_addr, <span class="keyword">socklen_t</span> *addrlen);</span><br><span class="line">参数：</span><br><span class="line"> sockfd：   创建套接字返回的描述符</span><br><span class="line"> buf：      接收的数据</span><br><span class="line"> len：      想要接收数据的长度</span><br><span class="line"> flags<span class="number">0</span>默认阻塞接收</span><br><span class="line"> saddr：    发送端地址信息</span><br><span class="line"> addrlen    地址信息长度（输入输出型参数）不但指定接收多长还要保存实际接受多长</span><br><span class="line"> 返回值：</span><br><span class="line"> 返回实际接受长度</span><br><span class="line"> <span class="number">-1</span> 失败</span><br><span class="line"> <span class="comment">//发送数据</span></span><br><span class="line"> <span class="keyword">ssize_t</span> sendto(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span><br><span class="line">                      <span class="keyword">const</span> struct sockaddr *dest_addr, <span class="keyword">socklen_t</span> addrlen);</span><br><span class="line">参数：</span><br><span class="line">sockfd：   创建套接字返回的描述符</span><br><span class="line"> buf：      发送的数据</span><br><span class="line"> len：      想要发送数据的长度</span><br><span class="line"> flags<span class="number">0</span>默认阻塞发送</span><br><span class="line"> daddr：     目的端信息</span><br><span class="line"> addrlen    地址信息长度</span><br><span class="line"> 返回值：</span><br><span class="line">成功：实际发送的长度</span><br><span class="line">失败： <span class="number">-1</span></span><br></pre></td></tr></table></figure><h4 id="socketaddr，socketaddr-in的辨析"><a href="#socketaddr，socketaddr-in的辨析" class="headerlink" title="socketaddr，socketaddr_in的辨析"></a>socketaddr，socketaddr_in的辨析</h4><p><img src="D:\MyBlog\source\images\sockaddr.png" alt=""></p><p><strong>传入sockaddr更加灵活，只用根据地址域来判断协议种类</strong></p><p>socket API是一层抽象的网络编程接口,适用于各种底层网络协议,如IPv4、IPv6,以及UNIX Domain ocket. 然而, 各种网络协议地址格式不同。</p><p>IPv4和IPv6的地址格式定义在netinet/in.h中,IPv4地址用sockaddr_in结构体表示,包括16位地址类型, 16 位端口号和32位IP地址.  IPv4、IPv6地址类型分别定义为常数AF_INET、AF_INET6. 这样,只要取得某种sockaddr结构体的首地址, 不需要知道具体是哪种类型的sockaddr结构体,就可以根据地址类型字段确定结构体中的内容. socket API可以都用struct sockaddr *类型表示, 在使用的时候需要强制转化成sockaddr_in; 这样的好 处是程序的通用性, 可以接收IPv4, IPv6, 以及UNIX Domain Socket各种类型的sockaddr结构体指针做为 参数; </p><h4 id="服务端需要bind（）绑定IP和port而客户端不需要为什么"><a href="#服务端需要bind（）绑定IP和port而客户端不需要为什么" class="headerlink" title="服务端需要bind（）绑定IP和port而客户端不需要为什么"></a>服务端需要bind（）绑定IP和port而客户端不需要为什么</h4><p>  因为服务器是时时在监听有没有客户端的连接，如果服务器不绑定IP和端口的话客户端上线的时候怎么连到服务器呢？所以服务器要绑定IP和端口而客户端就不需要了,客户端上线是主动向服务器发出请求的,因为服务器已经绑定了IP和端口,所以客户端上线的时候就向这个IP和端口发出请求,这时因为客户开始发数据了(发上线请求),系统就给客户端分配一个随机端口,这个端口和客户端的IP会随着上线请求一起发给服务器,服务收到上线请求后就可以从中获取发此请求的客户的IP和端口,接下来服务器就可以利用获取的IP和端口给客户端回应消息了.<strong>总之一句话,客户端是主动连接,而服务器是等待连接</strong>  </p><h3 id="用C-封装UDP"><a href="#用C-封装UDP" class="headerlink" title="用C++封装UDP"></a>用C++封装UDP</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UdpSocket</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Socket</span><span class="params">()</span></span>&#123;</span><br><span class="line">      _socket = socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP);</span><br><span class="line">      <span class="keyword">if</span>(_socket &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Bind</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> &amp;ip,<span class="keyword">uint16_t</span> port)</span></span>&#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">      addr.sin_family = AF_INET;</span><br><span class="line">      <span class="comment">//数字字节序转换将主机字节序转换为网络字节序</span></span><br><span class="line">      addr.sin_port = htons(port);</span><br><span class="line">      <span class="comment">//将点分十进制IP地址转换为网络字节序ip地址</span></span><br><span class="line">      addr.sin_addr.s_addr = inet_addr(ip.c_str());</span><br><span class="line">      <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(addr);</span><br><span class="line">      <span class="keyword">int</span> ret = bind(_socket,(struct sockaddr*)&amp;addr,len);</span><br><span class="line">      <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">"bind error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Recv</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> &amp;buf,sockaddr_in* saddr)</span></span>&#123;</span><br><span class="line">      <span class="keyword">char</span> tmp[<span class="number">1500</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">      <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">      <span class="keyword">int</span>  ret = recvfrom(_socket,tmp,<span class="number">1500</span>,<span class="number">0</span>,(struct sockaddr*)saddr,&amp;len);</span><br><span class="line">      <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">"recvfrom error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      buf.assign(tmp,ret);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Send</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; buf,struct sockaddr_in* daddr)</span></span>&#123;</span><br><span class="line">      <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">      <span class="keyword">int</span> ret = sendto(_socket,buf.c_str(),buf.size(),<span class="number">0</span>,(struct sockaddr*)daddr,len);</span><br><span class="line">      <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">"sendto error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Close</span><span class="params">()</span></span>&#123;</span><br><span class="line">      close(_socket);</span><br><span class="line">      _socket = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _socket;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="udp客户端："><a href="#udp客户端：" class="headerlink" title="udp客户端："></a>udp客户端：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"udpsocket.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECK_RET(q) <span class="meta-keyword">if</span>((q)==false)&#123;return -1;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(argc != <span class="number">3</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> ip = argv[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">uint16_t</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  UdpSocket sock;</span><br><span class="line">  CHECK_RET(sock.Socket());</span><br><span class="line"><span class="comment">//客户端不推荐手动绑定地址</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">srv_addr</span>;</span></span><br><span class="line">srv_addr.sin_family = AF_INET;</span><br><span class="line">srv_addr.sin_port = htons(port);</span><br><span class="line">srv_addr.sin_addr.s_addr = inet_addr(ip.c_str());</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> buf;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"client say:"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt;buf;</span><br><span class="line">    CHECK_RET(sock.Send(buf,&amp;srv_addr));</span><br><span class="line">    CHECK_RET(sock.Recv(buf,&amp;srv_addr));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"server say"</span>&lt;&lt;buf&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  sock.Close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="udp服务端"><a href="#udp服务端" class="headerlink" title="udp服务端"></a>udp服务端</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"udpsocket.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECK_RET(q) <span class="meta-keyword">if</span>((q)==false)&#123;return -1;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(argc != <span class="number">3</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> ip = argv[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">uint16_t</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">  <span class="comment">//创建套接字</span></span><br><span class="line">  UdpSocket sock;</span><br><span class="line">  CHECK_RET(sock.Socket());</span><br><span class="line">  <span class="comment">//绑定端口号</span></span><br><span class="line">  CHECK_RET(sock.Bind(ip,port));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> buf;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cli_addr</span>;</span></span><br><span class="line">    CHECK_RET(sock.Recv(buf,&amp;cli_addr));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"client say:"</span>&lt;&lt;buf&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"server say"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt;buf;</span><br><span class="line">    CHECK_RET(sock.Send(buf,&amp;cli_addr));</span><br><span class="line">  &#125;</span><br><span class="line">  sock.Close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用层</title>
      <link href="/2019/08/17/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
      <url>/2019/08/17/%E5%BA%94%E7%94%A8%E5%B1%82/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DNS系统</title>
      <link href="/2019/08/17/DNS%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/08/17/DNS%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="DNS系统"><a href="#DNS系统" class="headerlink" title="DNS系统"></a>DNS系统</h3><p>TCP/IP中使用IP地址和端口号来确定网络上的一台主机的一个程序. 但是IP地址不方便记忆。于是人们发明了一种叫主机名的东西, 是一个字符串, 并且使用hosts文件来描述主机名和IP地址的关系。最初, 通过互连网信息中心(SRI-NIC)来管理这个hosts文件的。如果一个新计算机要接入网络, 或者某个计算机IP变更, 都需要到信息中心申请变更hosts文件.。其他计算机也需要定期下载更新新版本的hosts文件才能正确上网。 为了方便使用以及管理，构建了DNS系统，一个组织的系统管理机构, 维护系统内的每个主机的IP和主机名的对应关系. 如果新计算机接入网络, 将这个信息注册到数据库中; 用户输入域名的时候, 会自动查询DNS服务器, 由DNS服务器检索数据库, 得到对应的IP地址。DNS是一整套从域名映射到IP的系统。</p><a id="more"></a><h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><p><img src="D:\MyBlog\source\images\域名.png" alt=""></p><h4 id="域名级别划分："><a href="#域名级别划分：" class="headerlink" title="域名级别划分："></a>域名级别划分：</h4><p><strong>域名的书写：由低级到高级</strong></p><p><img src="D:\MyBlog\source\images\顶级域名和二级域名的分类.png" alt=""></p><h4 id="域名系统是树形的——–域名树"><a href="#域名系统是树形的——–域名树" class="headerlink" title="域名系统是树形的——–域名树"></a>域名系统是树形的——–域名树</h4><p><img src="D:\MyBlog\source\images\域名树.png" alt=""></p><h4 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h4><h5 id="根域名服务器：最高层次的服务器"><a href="#根域名服务器：最高层次的服务器" class="headerlink" title="根域名服务器：最高层次的服务器"></a>根域名服务器：最高层次的服务器</h5><p>根域名服务器知道所有顶级域名服务器的域名和地址；在Internet上有13个不同IP地址的根域名服务器</p><p>名字是a.rootsuser.net~m.rootsuser.net</p><h5 id="顶级域名服务器："><a href="#顶级域名服务器：" class="headerlink" title="顶级域名服务器："></a>顶级域名服务器：</h5><p>管理该顶级域名服务器注册的所有的二级域名；</p><h5 id="权限域名服务器："><a href="#权限域名服务器：" class="headerlink" title="权限域名服务器："></a>权限域名服务器：</h5><p>负责一个区的域名服务器：</p><p>区：DNS服务器实际管辖的范围。</p><h5 id="本地域名服务器："><a href="#本地域名服务器：" class="headerlink" title="本地域名服务器："></a>本地域名服务器：</h5><p>不属于DNS系统；但是当主机发送域名查询请求的时候，这个查询请求报文就发给本地域名服务器。</p><h4 id="域名解析的流程"><a href="#域名解析的流程" class="headerlink" title="域名解析的流程"></a>域名解析的流程</h4><p>1、在浏览器中输入www . qq .com 域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。</p><p>2、如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。</p><p>3、如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/IP参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。</p><p>4、如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。</p><p>5、如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(<a href="https://link.zhihu.com/?target=http%3A//qq.com" target="_blank" rel="noopener">http://qq.com</a>)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找<a href="https://link.zhihu.com/?target=http%3A//qq.com" target="_blank" rel="noopener">http://qq.com</a>域服务器，重复上面的动作，进行查询，直至找到www . qq .com主机。</p><p>6、如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。 </p><p>从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。</p><h5 id="迭代查询：自己查"><a href="#迭代查询：自己查" class="headerlink" title="迭代查询：自己查"></a>迭代查询：自己查</h5><h5 id="递归查询：抱大腿"><a href="#递归查询：抱大腿" class="headerlink" title="递归查询：抱大腿"></a>递归查询：抱大腿</h5><h4 id="为什么根域名服务器有13个"><a href="#为什么根域名服务器有13个" class="headerlink" title="为什么根域名服务器有13个"></a>为什么根域名服务器有13个</h4><p>互联网域名系统 在层次结构的根部使用13个DNS服务器集群有几个原因：13号被选为网络可靠性和性能之间的折中，13是基于互联网协议（IP）的约束，版本4（IPv4）。</p><p>尽管IPv4中只存在13个指定的DNS根服务器名称，但实际上，这些名称中的每一个都不代表单个计算机，而是代表由多台计算机组成的服务器群集。这种使用集群可提高DNS的可靠性，而不会对其性能产生任何负面影响。</p><p>由于新出现的IP版本6标准对单个数据报的大小没有如此低的限制，我们可以预计，随着时间的推移，未来的DNS将包含更多的根服务器来支持IPv6。</p><p>原文链接：<a href="https://blog.csdn.net/weixin_41177699/article/details/80643486" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41177699/article/details/80643486</a></p><h4 id="为什么DNS使用UDP协议"><a href="#为什么DNS使用UDP协议" class="headerlink" title="为什么DNS使用UDP协议"></a>为什么DNS使用UDP协议</h4><p>答：不是只用了UDP服务，优先用了udp服务，因为开销小，这样的无连接的，尽最大能力交付的不可靠数据连接，    一次UDP名字服务器交换可以短到两个包：一个查询包、一个响应包。一次TCP交换则至少包含9个包：三次握手初始化TCP会话、一个查询包、一个响应包以及四次分手的包交换。    考虑到效率原因，TCP连接的开销大得，故采用UDP作为DNS的运输层协议，这也将导致只有13个根域名服务器的结果。只会在UDP报文中表明有截断的时候使用TCP查询。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++多态</title>
      <link href="/2019/08/16/C-%E5%A4%9A%E6%80%81/"/>
      <url>/2019/08/16/C-%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h1 id="C-多态"><a href="#C-多态" class="headerlink" title="C++多态"></a>C++多态</h1><p><strong>概念</strong>:多态的概念：通俗来说，就是多种形态，<strong>具体点就是去完成某个行为，当不同的对象去完成时会产生出不同</strong> </p><p><strong>的状态</strong>。举个栗子：比如<strong>买票这个行为</strong>，当<strong>普通人</strong>买票时，是全价买票；<strong>学生</strong>买票时，是半价买票；<strong>军人</strong>买票时是优 先买票。 </p><a id="more"></a><h4 id="多态的定义和实现"><a href="#多态的定义和实现" class="headerlink" title="多态的定义和实现"></a>多态的定义和实现</h4><h5 id="多态的构成条件"><a href="#多态的构成条件" class="headerlink" title="多态的构成条件:"></a>多态的构成条件:</h5><p>不同对象调用同一函数产生了不同的行为。那么在继承中要<strong>构成多态还有两个条件</strong>： </p><ol><li><p>必须通过基类的指针或者引用调用虚函数 （基类指针引用指向派生类对象才是安全的）</p></li><li><p>被调用的函数必须是虚函数，且派生类必须对基类的虚函数进行重写 </p></li></ol><p><img src="D:\MyBlog\source\images\多态.png" alt=""></p><h5 id="虚函数：即被vitrual修饰的成员函数我们称之为虚函数。"><a href="#虚函数：即被vitrual修饰的成员函数我们称之为虚函数。" class="headerlink" title="虚函数：即被vitrual修饰的成员函数我们称之为虚函数。"></a>虚函数：即被vitrual修饰的成员函数我们称之为虚函数。</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">true<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuyTicket</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">truetrue<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"success"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">true&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="虚函数的重写"><a href="#虚函数的重写" class="headerlink" title="虚函数的重写"></a>虚函数的重写</h5><p>虚函数的重写(覆盖)：<strong>派生类中有一个跟基类完全相同的虚函数</strong>（即派生类虚函数与基类虚函数的返回值类型、函数名字、参数列表完全相同)，称子类的虚函数重写了基类的虚函数。</p><p>注意：</p><pre><code>在重写基类虚函数时，派生类的虚函数在不加virtual关键字时，虽然也可以构成重写(因为继承后基类的虚函数被继承下来了在派生类依旧保持虚函数属性),但是该种写法不是很规范，不建议这样使用</code></pre><h5 id="虚函数重写的两个例外："><a href="#虚函数重写的两个例外：" class="headerlink" title="虚函数重写的两个例外："></a>虚函数重写的两个例外：</h5><h6 id="1-协变"><a href="#1-协变" class="headerlink" title="1.协变"></a>1.协变</h6><p>派生类重写基类虚函数时，与基类虚函数返回值类型不同。即基类虚函数返回基类对象的指针或者引 </p><p>用，派生类虚函数返回派生类对象的指针或引用时称为协变</p><h6 id="2-析构函数的重写（基类与派生类析构函数的名字不同"><a href="#2-析构函数的重写（基类与派生类析构函数的名字不同" class="headerlink" title="2. 析构函数的重写（基类与派生类析构函数的名字不同)"></a>2. 析构函数的重写（基类与派生类析构函数的名字不同)</h6><p>如果基类的析构函数为虚函数，此时派生类析构函数只要定义，<strong>无论是否加virtual关键字，都与基类的</strong> </p><p><strong>析构函数构成重写</strong>，虽然基类与派生类析构函数名字不同。虽然函数名不相同，看起来违背了重写的规 </p><p>则，其实不然，这里可以理解为编译器对析构函数的名称做了特殊处理，<strong>编译后析构函数的名称统一</strong>处 </p><p>理成<strong>destructor</strong>。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~Person() &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~Person()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~Student() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Student()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person* p1 = <span class="keyword">new</span> Person;</span><br><span class="line">Person* p2 = <span class="keyword">new</span> Student;</span><br><span class="line"><span class="keyword">delete</span> p1;</span><br><span class="line"><span class="keyword">delete</span> p2;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>只有派生类Student的析构函数重写了Person的析构函数，下面的delete对象调用析构函数，才能构成 </p><p>多态，才能保证p1和p2指向的对象正确的调用析构函数。</p><h5 id="C-11-override和-final"><a href="#C-11-override和-final" class="headerlink" title="C++11 override和 final"></a>C++11 override和 final</h5><ol><li><strong>final：修饰虚函数，表示该虚函数不能再被继承</strong></li><li><strong>override:</strong> <strong>检查派生类虚函数是否重写了基类某个虚函数，如果没有重写编译报错。</strong></li></ol><h5 id="重载，覆盖（重写），隐藏（重定义）的区别"><a href="#重载，覆盖（重写），隐藏（重定义）的区别" class="headerlink" title="重载，覆盖（重写），隐藏（重定义）的区别"></a>重载，覆盖（重写），隐藏（重定义）的区别</h5><p><img src="D:\MyBlog\source\images\隐藏重写重载.png" alt=""></p><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>在虚函数的后面写上 =0 ，则这个函数为纯虚函数。<strong>包含纯虚函数的类叫做抽象类（也叫接口类），抽象类</strong> </p><p><strong>不能实例化出对象</strong>。派生类继承后也不能实例化出对象，只有重写纯虚函数，派生类才能实例化出对象。纯 </p><p>虚函数规范了派生类必须重写，另外纯虚函数更体现出了接口继承。</p><p><strong>接口继承和现实继承</strong>：</p><p>普通函数的继承是一种实现继承，<strong>派生类继承了基类函数，可以使用函数，继承的是函数的实现</strong>。虚函数的 </p><p>继承是一种接口继承，派生类继承的是基类虚函数的接口，目的是为了重写，达成多态，继承的是接口。所 </p><p>以如果不实现多态，不要把函数定义成虚函数。</p><h4 id="多态实现的原理"><a href="#多态实现的原理" class="headerlink" title="多态实现的原理"></a>多态实现的原理</h4><h5 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> &#123;</span></span><br><span class="line">true<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">truetrue<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"haa"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">true&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">true<span class="keyword">int</span> _test;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过观察测试我们发现test类是8bytes，除了成员变量_test，还多一个vfptr放在对象的前面(注意有些平台可能会放到对象的最后面，这个跟平台有关),对象中的这个指针我们叫做虚函数表指针(v代表virtual，f代表function)。一个含有虚函数的类中都至少都有一个虚函数表指针，因为虚函数的地址要被放到虚函数表中， 虚函数表也简称虚表。</p><p><img src="D:\MyBlog\source\images\虚表指针.png" alt=""></p><p><strong>补充</strong>：</p><p>1.虚函数表本质是一个存<strong>虚函数指针的指针数组</strong>，这个数组最后面放了一个nullptr。</p><p>2.派生类的虚表生成：</p><p>a.先将基类中的虚表内容拷贝一份到派生类虚表中</p><p> b.如果派生类重写了基类中某个虚函数，用派生类自己的虚函数覆盖虚表中基类的虚函数 </p><p> c.派生类自己新增加的虚函数按其在派生类中的声明次序增加到派生类虚表的最后。</p><p><img src="D:\MyBlog\source\images\虚表指针内容.png" alt=""></p><p><strong>注意</strong></p><p><strong>虚表存的是虚函数指针，不是虚函数</strong>，虚函数和普通函数一样的，都是存在<strong>代码段的</strong>，只是他的指针又存到了虚表中。另外 对象中存的不是虚表，存的是虚表指针。</p><h5 id="多态实现的原理-1"><a href="#多态实现的原理-1" class="headerlink" title="多态实现的原理"></a>多态实现的原理</h5><ol><li>基类对象和派生类对象调用虚函数时在虚表中找的函数是不一样的。</li><li>这样就实现出了不同对象去完成同一行为时，展现出不同的形态。 </li><li>反过来思考我们要达到多态，有两个条件，一个是虚函数覆盖，一个是基类对象的指针或引用调用虚函数。 反思一下为什么？因为基类指针指向派生类对象是安全的 而派生类指向基类的地址是放大了范围是不安全的。</li><li><strong>满足多态以后的函数调用，不是在编译时确定的，是运行起来以后到对象的中取找的。不满足多态的函数调  用时编译时确认好的</strong></li></ol><h5 id="动态绑定与静态绑定"><a href="#动态绑定与静态绑定" class="headerlink" title="动态绑定与静态绑定"></a>动态绑定与静态绑定</h5><ol><li><p>静态绑定又称为前期绑定(早绑定 )，<strong>在程序编译期间确定了程序的行为</strong>，<strong>也称为静态多态</strong>，比如：函数重载 </p></li><li><p>动态绑定又称后期绑定(晚绑定)，是在程序运行期间，根据具体拿到的类型确定程序的具体行为，调用 具体的函数，<strong>也称为动态多态</strong>。  </p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++类和对象</title>
      <link href="/2019/08/15/C-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
      <url>/2019/08/15/C-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>   C++编译器不允许对象为零长度。试想一个长度为0的对象在内存中怎么存放？怎么获取它的地址？为了避免这种情况，C++强制给这种类插入一个缺省成员，长度为1。如果有自定义的变量，变量将取代这个缺省成员。</p><a id="more"></a><h1 id="C-类的初识"><a href="#C-类的初识" class="headerlink" title="C++类的初识"></a>C++类的初识</h1><h2 id="什么是类"><a href="#什么是类" class="headerlink" title="什么是类"></a>什么是类</h2><p>类就是对事物特征的抽象,也可以理解为一个模具,不是他所描述的具体的事物.c++中引入类也引入了一种新的编程思维,传统C语言是面向过程的我们解决问题时关注的时解决问题的步骤具体体现为函数,而面向对象编程关注的是对象的行为和对象间的交互</p><h2 id="类的引入和定义"><a href="#类的引入和定义" class="headerlink" title="类的引入和定义"></a>类的引入和定义</h2><p>C++中可以用struct 和 class定义类,区别是struct的成员默认访问方式是public，class是struct的成员默认访问方式 是private。</p><p>class为定义类的关键字，ClassName为类的名字，{}中为类的主体，注意类定义结束时后面分号。 类中的元素称为类的成员：类中的数据称为类的属性或者成员变量; 类中的函数称为类的方法或者成员函数。<br>类的两种定义方式：</p><ol><li>声明和定义全部放在类体中，需要注意：成员函数如果在类中定义，编译器可能会将其当成内联函数处 理。</li><li>声明放在.h文件中，类的定义放在.cpp文件中</li></ol><h2 id="类的访问限定符及封装"><a href="#类的访问限定符及封装" class="headerlink" title="类的访问限定符及封装"></a>类的访问限定符及封装</h2><h3 id="C-实现封装的方式"><a href="#C-实现封装的方式" class="headerlink" title="C++实现封装的方式"></a>C++实现封装的方式</h3><p>用类将对象的属性与方法结合在一块让对象更加完善，通过访问权限选择性的将其 接口提供给外部的用户使用。</p><h3 id="访问限定符的说明"><a href="#访问限定符的说明" class="headerlink" title="访问限定符的说明"></a>访问限定符的说明</h3><ol><li>public修饰的成员在类外可以直接被访问 </li><li>protected和private修饰的成员在类外不能直接被访问(此处protected和private是类似的) </li><li>访问权限作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止 </li><li>class的默认访问权限为private，struct为public(因为struct要兼容C)</li></ol><p>注意：访问限定符只在编译时有用，当数据映射到内存后，没有任何访问限定符上的区别</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装:"></a>封装:</h3><p>将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行 交互。</p><p>封装本质上是一种管理：我们如何管理兵马俑呢？比如如果什么都不管，兵马俑就被随意破坏了。那么我们 首先建了一座房子把兵马俑给封装起来。但是我们目的全封装起来，不让别人看。所以我们开放了售票通 道，可以买票突破封装在合理的监管机制下进去参观。类也是一样，我们使用类数据和方法都封装到一下。 不想给别人看到的，我们使用protected/private把成员封装起来。开放一些共有的成员函数对成员合理的访 问。所以封装本质是一种管理。 </p><h3 id="友元"><a href="#友元" class="headerlink" title="友元 :"></a>友元 :</h3><p><strong>友元分为</strong>：友元函数和友元类</p><p>友元提供了一种突破封装的方式，有时提供了便利。但是友元会增加耦合度，破坏了封装，所以友元不宜多用。</p><h4 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h4><p>友元函数可以直接访问类的私有成员，它是定义在类外部的普通函数，不属于任何类，但需要在类的内部声 明，声明时需要加friend关键字。</p><p><strong>注意:</strong></p><p>友元函数可访问类的私有成员，但不是类的成员函数 </p><p>友元函数不能用const修饰 </p><p>友元函数可以在类定义的任何地方声明，不受类访问限定符限制 一个函数可以是多个类的友元函数 </p><p>友元函数的调用与普通函数的调用和原理相同</p><h4 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h4><p>友元类的所有成员函数都可以是另一个类的友元函数，都可以访问另一个类中的非公有成员。<br>友元关系是单向的，不具有交换性。 比如上述Time类和Date类，在Time类中声明Date类为其友元类，那么可以在Date类中直接访问Time 类的私有成员变量，但想在Time类中访问Date类中私有的成员变量则不行。 </p><p>友元关系不能传递 如果B是A的友元，C是B的友元，则不能说明C时A的友元。</p><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><h4 id="概念及特性"><a href="#概念及特性" class="headerlink" title="概念及特性"></a>概念及特性</h4><p>概念：如果一个类定义在另一个类的内部，这个内部类就叫做内部类。注意此时这个内部类是一个独立的 类，它不属于外部类，更不能通过外部类的对象去调用内部类。外部类对内部类没有任何优越的访问权限。<br>注意：内部类就是外部类的友元类。注意友元类的定义，内部类可以通过外部类的对象参数来访问外部类中 的所有成员。但是外部类不是内部类的友元。<br>特性：</p><ol><li>内部类可以定义在外部类的public、protected、private都是可以的。 </li><li>注意内部类可以直接访问外部类中的static、枚举成员，不需要外部类的对象/类名。 </li><li>sizeof(外部类)=外部类，和内部类没有任何关系。</li></ol><h3 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域:"></a>类的作用域:</h3><p>类定义了一个新的作用域，类的所有成员都在类的作用域中。在类体外定义成员，需要使用 :: 作用域解析符指明成员属于哪个类域。</p><h3 id="类的实例化"><a href="#类的实例化" class="headerlink" title="类的实例化:"></a>类的实例化:</h3><ol><li>类只是一个模型一样的东西，限定了类有哪些成员，定义出一个类并没有分配实际的内存空间来存储它 </li><li>一个类可以实例化出多个对象，实例化出的对象  占用实际的物理空间，存储类成员变量 做个比方。类实例化出对象就像现实中使用建筑设计图建造出房子，类就像是设计图，只设计出需要什么东西，但是并没有实体的建筑存在，同样类也只是一个设计，<strong>实例化出的对象才能实际存储数据，占用物理空间</strong></li></ol><h4 id="类大小的计算"><a href="#类大小的计算" class="headerlink" title="类大小的计算:"></a>类大小的计算:</h4><h5 id="类的存储方式"><a href="#类的存储方式" class="headerlink" title="类的存储方式"></a>类的存储方式</h5><p>只保存成员变量，成员函数存放在公共的代码段 </p><h5 id="计算规则"><a href="#计算规则" class="headerlink" title="计算规则"></a>计算规则</h5><p>一个类的大小，实际就是该类中”成员变量”之和，当然也要进行内存对齐，注意空类的大小，空类比 较特殊，编译器给了空类一个字节来唯一标识这个类。</p><p><strong>空类的大小为什么是1?</strong></p><pre><code>C++编译器不允许对象为零长度。试想一个长度为0的对象在内存中怎么存放？怎么获取它的地址？为了避免这种情况，C++强制给这种类插入一个缺省成员，长度为1。如果有自定义的变量，变量将取代这个缺省成员。</code></pre><h4 id="结构体大小的计算——-内存对齐"><a href="#结构体大小的计算——-内存对齐" class="headerlink" title="结构体大小的计算——-内存对齐"></a>结构体大小的计算——-内存对齐</h4><ol><li>第一个成员在与结构体偏移量为0的地址处。 </li><li>其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。 注意：对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值。 VS中默认的对齐数为8，gcc中的对齐数为4 </li><li>结构体总大小为：最大对齐数（所有变量类型最大者与默认对齐参数取最小）的整数倍。 </li><li>如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是 所有最大对齐数（含嵌套结构体的对齐数）的整数倍。</li></ol><h2 id="一些更加深入的的讨论"><a href="#一些更加深入的的讨论" class="headerlink" title="一些更加深入的的讨论"></a>一些更加深入的的讨论</h2><h3 id="为什么要内存对齐"><a href="#为什么要内存对齐" class="headerlink" title="为什么要内存对齐?"></a>为什么要内存对齐?</h3><p>现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。</p><p>对齐的作用和原因：各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问一个没有进行对齐的变量的时候会发生错误,那么在这种架构下编程必须保证字节对齐.其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。显然在读取效率上下降很多。</p><p><strong>如何让结构体按照指定的对齐参数进行对齐</strong> </p><p>#pragma pack (2)</p><h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><ol><li>this指针的类型：类类型* const 2. </li><li>只能在“成员函数”的内部使用 </li><li>this指针本质上其实是一个成员函数的形参，是对象调用成员函数时，将对象地址作为实参传递给this 形参。所以对象中不存储this指针。</li><li>this指针是成员函数第一个隐含的指针形参，一般情况由编译器通过ecx寄存器自动传递，不需要用户 传递</li><li>this指针存放在栈上</li></ol><h3 id="this指针存在哪里？"><a href="#this指针存在哪里？" class="headerlink" title="this指针存在哪里？"></a>this指针存在哪里？</h3><p>其实编译器在生成程序时加入了获取对象首地址的相关代码。并把获取的首地址存放在了寄存器ECX中(VC++编译器是放在ECX中，其它编译器有可能不同)。也就是成员函数的其它参数正常都是存放在栈中。而this指针参数则是存放在寄存器中。类的静态成员函数因为没有this指针这个参数，所以类的静态成员函数也就无法调用类的非静态成员变量。</p><h3 id="this指针可以为空吗？"><a href="#this指针可以为空吗？" class="headerlink" title="this指针可以为空吗？"></a>this指针可以为空吗？</h3><p>可以为空，当我们在调用函数的时候，如果函数内部并不需要使用到this,也就是不需要通过this指向当前对象并对其进行操作时才可以为空(当我们在其中什么都不放或者在里面随便打印一个字符串)，如果调用的函数需要指向当前对象，并进行操作，则会发生错误（空指针引用）就跟C中一样不能进行空指针的引用</p><h2 id="类的六类默认函数"><a href="#类的六类默认函数" class="headerlink" title="类的六类默认函数"></a>类的六类默认函数</h2><p>如果一个类中什么成员都没有，简称为空类。空类中什么都没有吗？并不是的，任何一个类在我们不写的情 况下，都会自动生成下面6个默认成员函数。</p><p><strong>构造函数,析构函数,拷贝构造函数,赋值重载,const成员函数,取地址及const取地址操作符重载</strong> </p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p><strong>概念:</strong>构造函数是一个特殊的成员函数，<strong>名字与类名相同,创建类类型对象时由编译器自动调用，</strong>保证每个数据成员 都有 一个合适的初始值，<strong>并且在对象的生命周期内只调用一次</strong>。</p><p><strong>特性:</strong>构造函数是特殊的成员函数，需要注意的是，构造函数的虽然名称叫构造，但是需要注意的是构造函数的主 要任务并<strong>不是开空间创建对象，而是初始化对象</strong>。</p><h5 id="构造函数主要特征"><a href="#构造函数主要特征" class="headerlink" title="构造函数主要特征"></a>构造函数主要特征</h5><p>函数名与类名相同。 </p><p>无返回值。 </p><p>对象实例化时编译器自动调用对应的构造函数。</p><p>构造函数可以重载。</p><p>如果类中没有显式定义构造函数，则C++编译器会自动生成一个无参的默认构造函数，一旦用户显式定 义编译器将不再生成</p><p>无参的构造函数和全缺省的构造函数都称为默认构造函数，并且默认构造函数只能有一个。注意：无参 构造函数、全缺省构造函数、我们没写编译器默认生成的构造函数，都可以认为是默认成员函数。</p><p>C++把类型分成内置类型(基本类型)和自定义类型。内置类型就是语法已经定义好的类型：如 int/char…，自定义类型就是我们使用class/struct/union自己定义的类型, 编译器生成默认的构造函数会对自定类型成员_t调用的它的默认成员函数</p><h5 id="构造函数体赋值"><a href="#构造函数体赋值" class="headerlink" title="构造函数体赋值"></a>构造函数体赋值</h5><p>构造函数体赋值不能称作初始化因为初始化只有一次即在对象创建的时候,构造函数体可以多次赋值所以之=只能叫赋初值</p><h5 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h5><p>初始化列表：以一个冒号开始，接着是一个以逗号分隔的数据成员列表，每个”成员变量”后面跟一个放在括 号中的初始值或表达式。</p><p>​    </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">class</span> <span class="selector-tag">A</span> &#123;</span><br><span class="line"><span class="attribute">public</span>:</span><br><span class="line">true<span class="built_in">A</span>(int a,int b,int c)</span><br><span class="line">truetrue:<span class="built_in">_a</span>(a)</span><br><span class="line">truetrue,<span class="built_in">_b</span>(b)</span><br><span class="line">truetrue,<span class="built_in">_c</span>(c)</span><br><span class="line">true&#123;&#125;</span><br><span class="line"><span class="selector-tag">private</span>:</span><br><span class="line">true<span class="selector-tag">int</span> _<span class="selector-tag">a</span>;</span><br><span class="line">true<span class="selector-tag">int</span> _<span class="selector-tag">b</span>;</span><br><span class="line">true<span class="selector-tag">int</span> _<span class="selector-tag">c</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><p>每个成员变量在初始化列表中只能出现一次(初始化只能初始化一次) </p><p>  类中包含以下成员，必须放在初始化列表位置进行初始化：</p><p>  引用成员变量 </p><p>  const成员变量 </p><p>类类型成员(该类没有默认构造函数)</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:   </span><br><span class="line">trueB(<span class="keyword">int</span> a, <span class="keyword">int</span> <span class="keyword">ref</span>)</span><br><span class="line">true:_aobj(a)</span><br><span class="line">    , _ref(<span class="keyword">ref</span>)</span><br><span class="line">    , _n(<span class="number">10</span>)</span><br><span class="line">true&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">trueA _aobj;      <span class="comment">// 没有默认构造函数 </span></span><br><span class="line">true<span class="keyword">int</span>&amp; _ref;    <span class="comment">// 引用   </span></span><br><span class="line">true<span class="keyword">const</span> <span class="keyword">int</span> _n; <span class="comment">// const</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 尽量使用初始化列表初始化，因为不管你是否使用初始化列表，对于自定义类型成员变量，一定会先使 用初始化列表初始化。</p><p>成员变量在类中声明次序就是其在初始化列表中的初始化顺序，与其在初始化列表中的先后次序无关</p><p><strong>用explicit修饰构造函数，将会禁止单参构造函数的隐式转换。</strong></p><h5 id="static成员"><a href="#static成员" class="headerlink" title="static成员"></a><strong>static成员</strong></h5><p>声明为static的类成员称为类的静态成员，用static修饰的成员变量，称之为静态成员变量；用static修饰的 成员函数，称之为静态成员函数。静态的成员变量一定要在类外进行初始化</p><p>特点:</p><ol><li><p>静态成员为所有类对象所共享，不属于某个具体的实例</p></li><li><p>静态成员变量必须在类外定义，定义时不添加static关键字 </p></li><li><p>类静态成员即可用类名::静态成员或者对象.静态成员来访问 </p></li><li><p>静态成员函数没有隐藏的this指针，不能访问任何非静态成员 </p></li><li><p>静态成员和类的普通成员一样，也有public、protected、private3种访问级别，也可以具有返回值， const修饰符等参数</p><p>C++11支持非静态的成员变量直接初始化</p></li></ol><h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><p><strong>概念</strong>：与构造函数功能相反，析构函数不是完成对象的销毁，局部对象销毁工作是由编译器完成的。而对象在销毁时会自动调用析构函数，完成类的一些资源清理工作。</p><p>析构函数特征：</p><ol><li>析构函数名是在类名前加上字符 ~。 </li><li>无参数无返回值。 </li><li>一个类有且只有一个析构函数。若未显式定义，系统会自动生成默认的析构函数。 </li><li>对象生命周期结束时，C++编译系统系统自动调用析构函数。</li><li>关于编译器自动生成的析构函数，是否会完成一些事情呢？下面的程序我们会看到，编译器生成的 默认析构函数，对会自定类型成员调用它的析构函数。</li></ol><h4 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h4><p>构造函数：只有单个形参，该形参是对本类类型对象的引用(一般常用const修饰)，在用已存在的类类型对象创建新对象时由<strong>编译器自动调用</strong>。</p><h5 id="拷贝构造函数特征"><a href="#拷贝构造函数特征" class="headerlink" title="拷贝构造函数特征:"></a>拷贝构造函数特征:</h5><ol><li><p>拷贝构造函数是构造函数的一个重载形式。 </p></li><li><p>拷贝构造函数的参数只有一个且必须使用引用传参，使用传值方式会引发无穷递归调用。</p><p>这是因为传参数的时候形参是实参的一份拷贝,而形参并没有初始化,所以要调用拷贝构造</p><p>而调用拷贝构造函数时又创建了另一个形参又要拷贝构造所以会无穷递归,传引用就没有</p><p>调用拷贝构造</p></li></ol><p>   <img src="C:\Users\VSAS\AppData\Roaming\Typora\typora-user-images\1559629437160.png" alt="1559629437160"></p><ol start="3"><li>若未显示定义，系统生成默认的拷贝构造函数。 默认的拷贝构造函数对象按内存存储按字节序完成拷 贝，这种拷贝我们叫做浅拷贝，或者值拷贝。</li></ol><p><strong>下面这几种情况下会调用拷贝构造函数</strong></p><p>（1）显式或隐式地用同类型的一个对象来初始化另外一个对象。如上例中的CExample ccc = aaa;</p><p>（2）作为实参传递给一个函数。如上例中的bbb.myTestFunc(aaa);</p><p>（3）在函数体内返回一个对象时，也会调用返回值类型的拷贝构造函数</p><p>（4）初始化序列容器中的元素时。比如vector<string> svec(5)，string的缺省构造函数和拷贝构造函数都会被调用。</string></p><p>（5）用列表的方式初始化数组元素时。string a[] = {string(“hello”),string(“world”)};会调用string的拷贝构造函数。</p><h4 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h4><h5 id="运算符的重载"><a href="#运算符的重载" class="headerlink" title="运算符的重载"></a>运算符的重载</h5><p> C++为了增强代码的可读性引入了运算符重载，运算符重载是具有特殊函数名的函数，也具有其返回值类 型，函数名字以及参数列表，其返回值类型与参数列表与普通的函数类似。<br><strong>函数原型：返回值类型 operator操作符(参数列表)</strong><br>注意：<br><strong>不能通过连接其他符号来创建新的操作符</strong>：比如operator@ 重载操作符必须有一个类类型或者枚举类型的操作数 用于内置类型的操作符，其含义不能改变，例如：内置的整型+，不 能改变其含义<br>作为类成员的重载函数时，其形参看起来比操作数数目少1成员函数的 操作符有一个默认的形参this，限定为第一个形参 </p><p><strong>.* 、:: 、sizeof  、?:   、.  注意以上5个运算符不能重载。</strong></p><h5 id="赋值运算符重载-1"><a href="#赋值运算符重载-1" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h5><ol><li>参数类型 </li><li>返回值 </li><li>检测是否自己给自己赋值 </li><li>返回*this </li><li>一个类如果没有显式定义赋值运算符重载，编译器也会生成一个，完成对象按字节序的值拷贝。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信号量</title>
      <link href="/2019/08/15/%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
      <url>/2019/08/15/%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>信号是进程之间时间异步通知的方式，属于软中断，信号是一个标记每个信号表示一种事件，位图注册信号表示进程发生了这个事件，sigqueue节点添加一个表示这个事件发生了一次。</p><p>信号阻塞是阻止信号被递达（暂时不处理信号）在进程pcb中标记 那些信号来了不处理 在进程pcb中有个信号阻塞集，阻塞信号就是在这个集合做标记，当信号需要被处理时进行（pending&amp;~block）操作来判定这个信号需要阻塞还是递达。</p><a id="more"></a><h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>信号的基本认知</strong>:软件的中断,通知时间的发生，（进程之间时间异步通知的方式，属于软中断）</p><p><strong>生命周期</strong>：信号的生命周期:产生–&gt;注册–&gt;注销–&gt;处理/阻塞</p><h2 id="信号的种类"><a href="#信号的种类" class="headerlink" title="信号的种类"></a>信号的种类</h2><p><strong>查看方式：kill  -l</strong>，查看Linux下系统定义的信号列表，每个信号都有一个编号和一个宏定义名称,这些宏定义可以在signal.h中找到,这些信号各自在什么条件下 产生,默认的处理动作是什么,在signal(7)中都有详细明:<strong>man7signal</strong></p><p><img src="D:\MyBlog\source\images\signal.png" alt=""></p><p><strong>Linux下系统定义的信号列表</strong>：62种</p><p> <strong>1-31</strong>对应不同的事件     非可靠信号/非实时(事件可能会丢失/是否立即会处理)</p><p> <strong>34-64</strong>用户添加的信号    可靠信号/实时信号</p><p>信号的生命周期:产生–&gt;注册–&gt;注销–&gt;处理     阻塞</p><h2 id="信号的产生"><a href="#信号的产生" class="headerlink" title="信号的产生"></a>信号的产生</h2><h3 id="1-硬件产生"><a href="#1-硬件产生" class="headerlink" title="1.硬件产生:"></a>1.硬件产生:</h3><p>如键盘操作：Ctrl+c Ctrl+l Ctrl+z </p><h4 id="core-dump-解析"><a href="#core-dump-解析" class="headerlink" title="core dump 解析"></a>core dump 解析</h4><p><strong>core dumped :黑匣子,默认关闭,占磁盘资源</strong>当一个进程要异常终止时,可以选择把进程的用户空间内存数据全部 保存到磁 盘上,文件名通常是core,这叫做Core Dump。进程异常终止通常是因为有Bug,比如非法内存访问导致段错误, 事后可以用调试器检查core文件以查清错误原因,这叫做Post-mortem Debug（事后调试）。一个进程允许 产生多大的core文件取决于进程的Resource Limit(这个信息保存 在PCB中)。默认是不允许产生core文件的, 因为core文件中可能包含用户密码等敏感信息,不安全。在开发调试阶段可以用ulimit命令改变这个限制,允许 产生core文件。</p><p> 首先用ulimit命令改变Shell进程的Resource Limit,允许core文件最大为1024K: $ ulimit -c 1024</p><p>进程异常运行时，保存信息到core.pid文件中方便调试</p><p>ulimit -a 查看是否开启0</p><p>ulimit -c  1024 设置大小,开启核心转储文件</p><p>gdb./loop  –&gt; c ore-file core.pid –&gt;bt</p><h3 id="3-软件产生"><a href="#3-软件产生" class="headerlink" title="3.软件产生"></a>3.软件产生</h3><p>kill命令是调用kill（）函数实现的。kill函数可以给一个指定的进程发送指定的信号。</p><p>raise函数可以给当前进程发送指定 的信号(自己给自己发信号)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> signo)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">kill函数可以给一个指定的进程发送指定的信号。</span><br><span class="line">参数：</span><br><span class="line">   给指定进程发送指定信号</span><br><span class="line">   sig 信号种类</span><br><span class="line">返回值：</span><br><span class="line">成功返回<span class="number">0</span>,错误返回<span class="number">-1</span>。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> signo)</span></span>;</span><br><span class="line">参数：</span><br><span class="line">raise函数可以给当前进程发送指定的信号</span><br><span class="line">参数：</span><br><span class="line">sig 信号种类</span><br><span class="line">返回值：</span><br><span class="line">这两个函数都是成功返回<span class="number">0</span>,错误返回<span class="number">-1</span>。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abort</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">给调用进程发送SIGABRT信号</span><br><span class="line">就像<span class="built_in">exit</span>函数一样,<span class="built_in">abort</span>函数总是会成功的,所以没有返回值。</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>;</span><br><span class="line">给调用进程指定时间后发送SIGALRM信号</span><br><span class="line">返回上一个定时器剩余的时间或<span class="number">0</span></span><br><span class="line">参数为<span class="number">0</span>表示取消定时器返回上一个定时器的剩余时间</span><br></pre></td></tr></table></figure><h2 id="信号注册"><a href="#信号注册" class="headerlink" title="信号注册"></a>信号注册</h2><h3 id="信号的相关概念"><a href="#信号的相关概念" class="headerlink" title="信号的相关概念"></a>信号的相关概念</h3><ul><li>实际执行信号的处理动作称为<strong>信号递达</strong>(Delivery) </li><li>信号从产生到递达之间的状态,称为<strong>信号未决</strong>(Pending)。 </li><li>进程可以选择阻塞 (Block )某个信号。 </li><li>被阻塞的信号产生时将保持在未决状态,直到进程解除对此信号的阻塞,才执行递达的动作. </li><li>注意,阻塞和忽略是不同的,只要信号被阻塞就不会递达,而忽略是在递达之后可选的一种处理动作。  </li></ul><h3 id="在内核中的表示"><a href="#在内核中的表示" class="headerlink" title="在内核中的表示"></a>在内核中的表示</h3><p><img src="D:\MyBlog\source\images\sigpending.png" alt=""></p><p>在pcb中做标记：<strong>修改未决信号集合（</strong>位图）中对应的信号位。每个<strong>信号都有两个标志位分别表示阻塞(block)和未决(pending)</strong>,还有一个<strong>函数指针表示处理动作</strong>。信号产生时,内核在进程控制块（pcb）中设置该信号的未决标志,直到信号递达才清除该标志。在上图的例子 中,SIGHUP信号未阻塞也未产生过,当它递达时执行默认处理动作。 SIGINT信号产生过,但正在被阻塞,所以暂时不能递达。虽然它的处理动作是忽略,但在没有解除阻塞之前不能忽略这个信号,因为进程仍有机会改变处理动作之后再解除阻塞。 SIGQUIT信号未产生过,一旦产生SIGQUIT信号将被阻塞,它的处理动作是用户自定义函数sighandler（）。 </p><p>如果在进程解除对某信号的阻塞之前这种信号产生过多次,将如何处理?POSIX.1允许系统递送该信号一次 或多次。Linux是这样实现的:常规信号在递达之前产生多次只计一次,而实时信号在递达之前产生多次可 以依次放在一个队列里（sigqueue）</p><h4 id="sigset"><a href="#sigset" class="headerlink" title="sigset"></a>sigset</h4><p>每个信号只有一个bit的未决标志,非0即1,不记录该信号产生了多少次,阻塞标志也是这样表示的。 因此,未决和阻塞标志可以用相同的数据类型sigset_t来存储,sigset_t称为信号集,这个类型可以表示每个信号 的“有效”或“无效”状态,在阻塞信号集中“有效”和“无效”的含义是该信号是否被阻塞,而在未决信号集中“有 效”和“无效”的含义是该信号是否处于未决状态。下一节将详细介绍信号集的各种操作。 阻塞信号集也叫做当 前进程的信号屏蔽字(Signal Mask),这里的“屏蔽”应该理解为阻塞而不是忽略。 </p><h3 id="信号的注册"><a href="#信号的注册" class="headerlink" title="信号的注册"></a>信号的注册</h3><p><strong>非可靠信号的注册</strong>：判断是否有相同的未决信号，若有，则什么也不做；否则修改位图添加结点</p><p><strong>可靠信号的注册</strong>：是否有相同未决信号的注册，若没有修改位图添加节点；否则直接添加结点</p><h2 id="信号的注销"><a href="#信号的注销" class="headerlink" title="信号的注销"></a>信号的注销</h2><p>非可靠信号注销：删除信号的sigqueue结点，修改位图（非可靠信号只会注册一次）</p><p>可靠信号注册：删除节点，检测是否还有相同信号，若有则位图依然置1否则修改为0</p><h2 id="信号的处理："><a href="#信号的处理：" class="headerlink" title="信号的处理："></a>信号的处理：</h2><h4 id="默认处理方式："><a href="#默认处理方式：" class="headerlink" title="默认处理方式："></a>默认处理方式：</h4><p>操作系统(内核)既定的处理方式—-SIG_DFL，可能是以下的某种类型：</p><p>Treminate：进程被终止(杀死)</p><p>Dump：进程被终止(杀死)，如果可能，创建包含进程执行上下文的核心转储文件(core dump)</p><p>Ignore：信号被忽略</p><p>Stop：进程被停止，即把进程置为TASK_STOPPED状态</p><h4 id="忽略处理方式"><a href="#忽略处理方式" class="headerlink" title="忽略处理方式"></a>忽略处理方式</h4><p>这与默认中的忽略是不同的，该处理方式处理了信号，但是什么都没有做</p><h4 id="​-自定义处理方式"><a href="#​-自定义处理方式" class="headerlink" title="​ 自定义处理方式"></a>​ 自定义处理方式</h4><p>提供一个信号处理函数,要求内核在处理该信号时切换到用户态执行这个处理函数,这种方式称为捕捉Catch)一个信号。<strong>有两个信号无法被阻塞,忽略,自定义SIGKILL,SIGSTOP19</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">sighandler_t</span> signal(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler);</span><br><span class="line">参数：</span><br><span class="line">signum信号编号</span><br><span class="line">handler 函数指针使用函数指针替换signum的处理方式</span><br><span class="line"></span><br><span class="line">SIG_DFL ：默认</span><br><span class="line">SIG_IGN ：忽略</span><br></pre></td></tr></table></figure><h4 id="自定信号处理方式的处理流程："><a href="#自定信号处理方式的处理流程：" class="headerlink" title="自定信号处理方式的处理流程："></a>自定信号处理方式的处理流程：</h4><p>用户态切换到内核态，完毕后准备从内核态切换回用户态的时候去处理信号若信号为默认或者忽略处理，则在内核中直接完成，但是信号如果是自定义的处理方式，则需要返回用户态执行信号回调函数，执行完毕后回到内核态没有信号则回到信号主流程</p><p><img src="D:\MyBlog\source\images\信号捕捉.png" alt=""></p><h4 id="自定义信号捕捉"><a href="#自定义信号捕捉" class="headerlink" title="自定义信号捕捉"></a>自定义信号捕捉</h4><p>如果信号的处理动作是用户自定义函数,在信号递达时就调用这个函数,这称为捕捉信号。由于信号处理函数的代码 是在用户空间的,处理过程比较复杂,举例如下: 用户程序注册了SIGQUIT信号的处理函数sighandler。 当前正在执行 main函数,这时发生中断或异常切换到内核态。 在中断处理完毕后要返回用户态的main函数之前检查到有信号 SIGQUIT递达。 内核决定返回用户态后不是恢复main函数的上下文继续执行,而是执行sighandler函数,sighandler 和main函数使用不同的堆栈空间,它们之间不存在调用和被调用的关系,是 两个独立的控制流程。 sighandler函数返 回后自动执行特殊的系统调用sigreturn再次进入内核态。 如果没有新的信号要递达,这次再返回用户态就是恢复 main函数的上下文继续执行了。 </p><h5 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction"></a>sigaction</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signo, <span class="keyword">const</span> struct sigaction *act, struct sigaction *oact)</span></span>; </span><br><span class="line">参数：</span><br><span class="line">sigaction函数可以读取和修改与指定信号相关联的处理动作。调用成功则返回<span class="number">0</span>,出错则返回- <span class="number">1</span>。signo</span><br><span class="line">是指定信号的编号。若act指针非空,则根据act修改该信号的处理动作。若oact指针非 空,则通过oact传</span><br><span class="line">出该信号原来的处理动作。act和oact指向sigaction结构体:</span><br><span class="line">将sa_handler赋值为常数SIG_IGN传给sigaction表示忽略信号,赋值为常数SIG_DFL表示执行系统默认动</span><br><span class="line">作,赋值为一个函数指针表示用自定义函数捕捉信号,或者说向内核注册了一个信号处理函 数,该函数返回</span><br><span class="line">值为<span class="keyword">void</span>,可以带一个<span class="keyword">int</span>参数,通过参数可以得知当前信号的编号,这样就可以用同一个函数处理多种信</span><br><span class="line">号。显然,这也是一个回调函数,不是被main函数调用,而是被系统所调用。</span><br><span class="line">当某个信号的处理函数被调用时,内核自动将当前信号加入进程的信号屏蔽字,当信号处理函数返回时自动恢复原来</span><br><span class="line">的信号屏蔽字,这样就保证了在处理某个信号时,如果这种信号再次产生,那么 它会被阻塞到当前处理结束为止。 如果</span><br><span class="line">在调用信号处理函数时,除了当前信号被自动屏蔽之外,还希望自动屏蔽另外一些信号,则用sa_mask字段说明这些需</span><br><span class="line">要额外屏蔽的信号,当信号处理函数返回时自动恢复原来的信号屏蔽字。 sa_flags字段包含一些选项,本章的代码都</span><br><span class="line">把sa_flags设为<span class="number">0</span>,sa_sigaction是实时信号的处理函数</span><br></pre></td></tr></table></figure><h4 id="函数的可重入与不可重入"><a href="#函数的可重入与不可重入" class="headerlink" title="函数的可重入与不可重入"></a>函数的可重入与不可重入</h4><p>一个函数是否可以在多个运行时序中重复调用而不会出现任何问题，在一个函数中是否进行了对全局数据的非原子性操作。</p><p><strong>可重入函数：</strong>在多个时序的运行中重复调用，不会造成异常影响。比如在某个函数的调用中，还没有返回时就再次进入该函数，就称为重入。</p><p><strong>不可重入函数：</strong>不能再多个时序中重复调用，比如malloc和free函数。如果随意的调用则会发生内存泄漏。</p><p>时序的竞争执行：函数的可重入与不可重入（是否进行了）对全局数据的非原子性操作</p><p>关键字：volatile：保持内存可见性—防止编译器过度优化-每次对变量访问都从内存重新获取</p><h4 id="SIGCHLD"><a href="#SIGCHLD" class="headerlink" title="SIGCHLD"></a>SIGCHLD</h4><p>SIGCHLD：子进程退出，操作系统通知父进程，自定义一个SIGCGLD信号处理方式sigcb，当子进程退出操作系统发送信号给父进程直接触发信号回调sigbc用户主要在sigbc中调用wait/wait_pid就可以处理子进程退出sigchld是一个非可靠信号，假如有多个子进程同时退出则有可能造成事件丢失导致sigbc只被调用一次，只处理了一个子进程因此需要在sigcb中需要用户循环非阻塞处理子进程退出，直到没有子进程退出while（waitpid（-11，NULL，WONOHANG）&gt; 0)//因为&gt;0表示有子进程退出必须用非阻塞，否则没有子进程·退出的时候waitpid将阻塞导致进程无法回到主控流程  </p><h3 id="信号集操作函数"><a href="#信号集操作函数" class="headerlink" title="信号集操作函数"></a>信号集操作函数</h3><h4 id="初始化函数"><a href="#初始化函数" class="headerlink" title="初始化函数"></a>初始化函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">函数sigemptyset初始化<span class="built_in">set</span>所指向的信号集,使其中所有信号的对应bit清零,表示该信号集不包含 任何有效信号。</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">函数sigfillset初始化<span class="built_in">set</span>所指向的信号集,使其中所有信号的对应bit置位,表示 该信号集的有效信号包括系统支持的所有信号</span><br><span class="line">注意：</span><br><span class="line">在使用sigset_ t类型的变量之前,一定要调 用sigemptyset或sigfillset做初始化,使信号集处于确定的</span><br><span class="line">状态。</span><br><span class="line">返回值：</span><br><span class="line">函数都是成功返回<span class="number">0</span>,出错返回<span class="number">-1</span>。</span><br></pre></td></tr></table></figure><h4 id="操作函数"><a href="#操作函数" class="headerlink" title="操作函数"></a>操作函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">初始化<span class="keyword">sigset_t</span>变量之后就可以在调用sigaddset和sigdelset在该信号集中添加或删除某种有效信号。</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span> <span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signo)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signo)</span></span>;</span><br><span class="line">函数都是成功返回<span class="number">0</span>,出错返回<span class="number">-1</span>。</span><br><span class="line"><span class="keyword">int</span> sigismember（<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signo);</span><br><span class="line">sigismember是一个布尔函数,用于判断一个信号集的有效信号中是否包含某种 信号,若包含则返回<span class="number">1</span>,不包含则返回<span class="number">0</span>,出错返回<span class="number">-1</span>。</span><br></pre></td></tr></table></figure><h4 id="阻塞信号信号集"><a href="#阻塞信号信号集" class="headerlink" title="阻塞信号信号集"></a>阻塞信号信号集</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">sigset_t</span> *oset)</span></span>; </span><br><span class="line">返回值:若成功则为<span class="number">0</span>,若出错则为<span class="number">-1</span></span><br><span class="line">参数：</span><br><span class="line">如果oset是非空指针,则读取进程的当前信号屏蔽字通过oset参数传出。<span class="number">4</span>如果<span class="built_in">set</span>是非空指针,则 更改进程的信</span><br><span class="line">号屏蔽字,参数how指示如何更改。如果oset和<span class="built_in">set</span>都是非空指针,则先将原来的信号 屏蔽字备份到oset里,然后</span><br><span class="line">根据<span class="built_in">set</span>和how参数更改信号屏蔽字</span><br><span class="line">参数how：</span><br><span class="line">trueSIG_BLOCK:<span class="built_in">set</span>包含了我们希望添加到当前信号屏蔽字的信号相当于mask=mask|<span class="built_in">set</span></span><br><span class="line">trueSIG_UNBLOCK:<span class="built_in">set</span>包含了我们希望从当前信号屏蔽字中解除的阻塞信号相当于mask=mask|~<span class="built_in">set</span></span><br><span class="line">trueSIG_SETMASK:设置当前屏蔽字信号为<span class="built_in">set</span>所指向的值相当于mask = <span class="built_in">set</span></span><br><span class="line">注意：</span><br><span class="line">true如果调用sigprocmask解除了对当前若干个未决信号的阻塞,则在sigprocmask返回前,至少将其中一个信号递</span><br><span class="line">达。</span><br></pre></td></tr></table></figure><h4 id="sigpending"><a href="#sigpending" class="headerlink" title="sigpending"></a>sigpending</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpending</span><span class="params">(<span class="keyword">sigset_t</span>* <span class="built_in">set</span>)</span></span></span><br><span class="line">读取当前进程的未决信号集,通过set参数传出。调用成功则返回0,出错则返回-1。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>socket编程--TCP</title>
      <link href="/2019/07/19/socket%E7%BC%96%E7%A8%8B-TCP/"/>
      <url>/2019/07/19/socket%E7%BC%96%E7%A8%8B-TCP/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP网络编程"><a href="#TCP网络编程" class="headerlink" title="TCP网络编程"></a>TCP网络编程</h2><h4 id="TCP网络编程流程"><a href="#TCP网络编程流程" class="headerlink" title="TCP网络编程流程"></a>TCP网络编程流程</h4><p><img src="D:\MyBlog\source\images\tcp流程.png" alt=""></p><a id="more"></a><h4 id="socket的API接口："><a href="#socket的API接口：" class="headerlink" title="socket的API接口："></a>socket的API接口：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 socket 文件描述符 (TCP/UDP, 客户端 + 服务器) </span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"> 参数：</span><br><span class="line"> domain：地址域</span><br><span class="line"> AF_INET:IPV4网路协议地址域</span><br><span class="line"> type：套接字类型</span><br><span class="line"> SOCK_STREAM  流式套接字，默认协议TCP不支持UDP</span><br><span class="line"> SOCK_DGRAM   数据报套接字 默认UDP，不支持TCP</span><br><span class="line"> protocol：协议类型</span><br><span class="line"> <span class="number">0</span>：使用套接字默认协议</span><br><span class="line"> <span class="number">6</span>/IPPROTO_TCP tcp协议</span><br><span class="line"> <span class="number">17</span>/IPPROTO_TCP UDP协议</span><br><span class="line"> 返回值：</span><br><span class="line"> 套接字操作句柄文件描述符</span><br><span class="line"> 失败<span class="number">-1</span>；</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定端口号 (TCP/UDP, 服务器)      </span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> socket, <span class="keyword">const</span> struct sockaddr *address,  </span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">socklen_t</span> address_len)</span></span>;</span><br><span class="line">  参数：</span><br><span class="line">  sockfd：   创建套接字返回的描述符</span><br><span class="line">  addr：     地址信息</span><br><span class="line">  addrlen    地址信息长度</span><br><span class="line">  返回值      失败返回<span class="number">-1</span>成功<span class="number">0</span></span><br><span class="line"> <span class="comment">//接受数据</span></span><br><span class="line">  <span class="keyword">ssize_t</span> recvfrom(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span><br><span class="line">                        struct sockaddr *src_addr, <span class="keyword">socklen_t</span> *addrlen);</span><br><span class="line">参数：</span><br><span class="line"> sockfd：   创建套接字返回的描述符</span><br><span class="line"> buf：      接收的数据</span><br><span class="line"> len：      想要接收数据的长度</span><br><span class="line"> flags<span class="number">0</span>默认阻塞接收</span><br><span class="line"> saddr：    发送端地址信息</span><br><span class="line"> addrlen    地址信息长度（输入输出型参数）不但指定接收多长还要保存实际接受多长</span><br><span class="line"> 返回值：</span><br><span class="line"> 返回实际接受长度</span><br><span class="line"> <span class="number">-1</span> 失败</span><br><span class="line"> <span class="comment">//发送数据</span></span><br><span class="line"> <span class="keyword">ssize_t</span> sendto(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span><br><span class="line">                      <span class="keyword">const</span> struct sockaddr *dest_addr, <span class="keyword">socklen_t</span> addrlen);</span><br><span class="line">参数：</span><br><span class="line">sockfd：   创建套接字返回的描述符</span><br><span class="line"> buf：      发送的数据</span><br><span class="line"> len：      想要发送数据的长度</span><br><span class="line"> flags<span class="number">0</span>默认阻塞发送</span><br><span class="line"> daddr：     目的端信息</span><br><span class="line"> addrlen    地址信息长度</span><br><span class="line"> 返回值：</span><br><span class="line">成功：实际发送的长度</span><br><span class="line">失败： <span class="number">-1</span></span><br></pre></td></tr></table></figure><h4 id="Listen（）"><a href="#Listen（）" class="headerlink" title="Listen（）"></a>Listen（）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> socket, <span class="keyword">int</span> backlog)</span></span>;开始监听socket (TCP, 服务器) </span><br><span class="line">参数：</span><br><span class="line"> socket：套接字描述符</span><br><span class="line"> 被listen函数作用的套接字，sockfd之前由socket函数返回。在被socket函数返回的套接字fd之时，它是一个   主动连接的套接字，也就是此时系统假设用户会对这个套接字调用connect函数，期待它主动与其它进程连接，然后   在服务器编程中，用户希望这个套接字可以接受外来的连接请求，也就是被动等待用户来连接。由于系统默认时认为   一个套接字是主动连接的，所以需要通过某种方式来告诉系统，用户进程通过系统调用listen来完成这件事。</span><br><span class="line"> backlog：最大监听数目</span><br><span class="line"> 如果将 backlog 的值设置为 SOMAXCONN，就由系统来决定请求队列长度，这个值一般比较大，可能是几百，或   者更多。</span><br></pre></td></tr></table></figure><p>Listen（）函数在一个socket的句柄上监听连接。这个函数可以让sockfd参数引用的那个socket的句柄标记成一个<strong>被动式的socket,</strong>即所谓被动监听，是指当没有客户端请求时，套接字处于“睡眠”状态，只有当接收到客户端请求时，套接字才会被“唤醒”来响应请求。</p><p>当进程处理一个一个连接请求的时候，可能还存在其它的连接请求。因为TCP连接是一个过程，所以可能存在一种半连接的状态，有时由于同时尝试连接的用户过多，使得服务器进程无法快速地完成连接请求。如果这个情况出现了，服务器进程希望内核如何处理呢？内核会在自己的进程空间里维护一个队列（baklog）以跟踪这些完成的连接但服务器进程还没有接手处理（已完成连接队列）或正在进行的连接（未完成连接队列），这样的一个队列内核不可能让其任意大，所以必须有一个大小的上限。这个backlog告诉内核使用这个数值作为上限。</p><p><img src="D:\MyBlog\source\images\tcp监听.png" alt=""></p><h4 id="accpect"><a href="#accpect" class="headerlink" title="accpect()"></a>accpect()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收请求 (TCP, 服务器) </span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> socket, struct sockaddr* address,          </span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">socklen_t</span>* address_len)</span></span>;</span><br><span class="line">accept函数主要用于服务器端，一般位于listen函数之后，默认会阻塞进程，直到有一个客户请求连接，建立好连接后，它返回的一个新的套接字 socketfd_new ，此后，服务器端即可使用这个新的套接字socketfd_new与该客户端进行通信，而sockfd 则继续用于监听其他客户端的连接请求。</span><br><span class="line">阻塞：</span><br><span class="line">如果队列中没有等待的连接，套接字也没有被标记为Non-blocking，accept()会阻塞调用函数直到连接出现；如果套接字被标记为Non-blocking，队列中也没有等待的连接，accept()返回错误EAGAIN或EWOULDBLOCK。</span><br></pre></td></tr></table></figure><h4 id="connect"><a href="#connect" class="headerlink" title="connect()"></a>connect()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立连接 (TCP, 客户端) </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr,         </span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">socklen_t</span> addrlen)</span></span>; </span><br><span class="line">参数sockfd</span><br><span class="line">指定数据发送的套接字，解决从哪里发送的问题。内核需要维护大量IO通道，所以用户必需通过这个参数告诉内核从哪个IO通道，此处就是从哪个socket接口中发送数据。sockfd是先前socket返回的值。</span><br><span class="line">参数server_addr</span><br><span class="line">指定数据发送的目的地，也就是服务器端的地址。这里服务器是针对connect说的，因为connect是主动连接的一方调用的，所以相应的要存在一个被连接的一方，被动连接的一方需要调用listen以接受connect的连接请求，如此被动连接的一方就是服务器了。</span><br><span class="line">参数addrlen</span><br><span class="line">指定server_addr结构体的长度。我们知道系统中存在大量的地址结构，但socket接口只是通过一个统一的结构来指定参数类型，所以需要指定一个长度，以使内核在进行参数复制的时候有个有个界限。</span><br></pre></td></tr></table></figure><h4 id="c-封装TCP接口"><a href="#c-封装TCP接口" class="headerlink" title="c++封装TCP接口"></a>c++封装TCP接口</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">include &lt;iostream&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TcpSocket</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    TcpSocket():_sockfd(<span class="number">-1</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetSockfd</span><span class="params">(<span class="keyword">int</span> newfd)</span></span>&#123;</span><br><span class="line">      _sockfd = newfd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Socket</span><span class="params">()</span></span>&#123;</span><br><span class="line">     _sockfd = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);</span><br><span class="line">     <span class="keyword">if</span>(_sockfd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">       perror(<span class="string">"socket error"</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Bind</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; ip,<span class="keyword">uint16_t</span> port)</span></span>&#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">      addr.sin_family = AF_INET;</span><br><span class="line">      addr.sin_port = htons(port);</span><br><span class="line">      addr.sin_addr.s_addr = inet_addr(ip.c_str());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(sockaddr_in);</span><br><span class="line">      <span class="keyword">int</span> ret = bind(_sockfd,(struct sockaddr*)&amp;addr,len);</span><br><span class="line">      <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">"bind error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Listen</span><span class="params">(<span class="keyword">int</span> backlog = <span class="number">10</span>)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> ret = listen(_sockfd,backlog);</span><br><span class="line">      <span class="keyword">if</span>(ret &lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">"listen error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Connect</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; ip,<span class="keyword">uint16_t</span> port)</span></span>&#123;</span><br><span class="line">      sockaddr_in addr;</span><br><span class="line">     addr.sin_family = AF_INET;</span><br><span class="line">     addr.sin_port = htons(port);</span><br><span class="line">     addr.sin_addr.s_addr = inet_addr(ip.c_str());</span><br><span class="line">     <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">      <span class="keyword">int</span> ret = connect(_sockfd,(struct sockaddr*)&amp;addr,len);</span><br><span class="line">      <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">"connect error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Recv</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; buf)</span></span>&#123;</span><br><span class="line">      <span class="keyword">char</span> tmp[<span class="number">4096</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">      <span class="keyword">ssize_t</span> ret = recv(_sockfd,tmp,<span class="number">4096</span>,<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">"recv error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"perr shutdown"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      buf.assign(tmp,ret);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Accept</span><span class="params">(TcpSocket&amp; csock,struct sockaddr_in* addr = <span class="literal">NULL</span>)</span></span>&#123;</span><br><span class="line">           <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> _<span class="title">addr</span>;</span></span><br><span class="line">           <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(addr);</span><br><span class="line">           <span class="keyword">int</span> newfd = accept(_sockfd,(struct sockaddr*)&amp;_addr,&amp;len);</span><br><span class="line">           <span class="keyword">if</span>(newfd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">             perror(<span class="string">"accept error"</span>);</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(addr != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(addr,&amp;_addr,len);</span><br><span class="line">           &#125;</span><br><span class="line">           csock.SetSockfd(newfd);</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Send</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; buf)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> ret = send(_sockfd,buf.c_str(),buf.size(),<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">"send error"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Close</span><span class="params">()</span></span>&#123;</span><br><span class="line">      close(_sockfd);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _sockfd;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="TCPSEVER"><a href="#TCPSEVER" class="headerlink" title="TCPSEVER"></a>TCPSEVER</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tcpsocket.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECK_RIGHT(q) <span class="meta-keyword">if</span>((q == false)) &#123;return -1;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(argc &lt; <span class="number">3</span>)&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"./tcp_srv ip port"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> ip = argv[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">uint16_t</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  TcpSocket sock;</span><br><span class="line">  CHECK_RIGHT(sock.Socket());</span><br><span class="line">  CHECK_RIGHT(sock.Bind(ip,port));</span><br><span class="line">  CHECK_RIGHT(sock.Listen());</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    TcpSocket clisock;</span><br><span class="line">    sockaddr_in addr;</span><br><span class="line">    <span class="keyword">if</span>(sock.Accept(clisock,&amp;addr) == <span class="literal">false</span>)&#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> buf;</span><br><span class="line">    clisock.Recv(buf);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"client say:"</span>&lt;&lt;buf&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">buf.clear();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"sever say"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt;buf;</span><br><span class="line">  &#125;</span><br><span class="line">  sock.Close();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TCPClient"><a href="#TCPClient" class="headerlink" title="TCPClient"></a>TCPClient</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tcpsocket.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECK_RIGHT(q) <span class="meta-keyword">if</span>((q == false)) &#123;return -1;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(argc &lt; <span class="number">3</span>)&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"./tcp_cli ip port"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> ip = argv[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">uint16_t</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  TcpSocket sock;</span><br><span class="line">  CHECK_RIGHT(sock.Socket());</span><br><span class="line">  CHECK_RIGHT(sock.Connect(ip,port));</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> buf;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"client say"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt;buf;</span><br><span class="line">    sock.Send(buf);</span><br><span class="line"></span><br><span class="line">    buf.clear();</span><br><span class="line">    sock.Recv(buf);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"server say:"</span>&lt;&lt;buf&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  sock.Close();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Http应用层协议</title>
      <link href="/2019/06/16/Http%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE/"/>
      <url>/2019/06/16/Http%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><h3 id="URL-统一资源定位符"><a href="#URL-统一资源定位符" class="headerlink" title="URL:统一资源定位符"></a>URL:统一资源定位符</h3><p>协议名称://用户名:密码@服务器地址:服务器端口/资源路径?查询字符串#片段标识符</p><p><img src="D:\MyBlog\source\images\url格式图.png" alt=""></p><h3 id="URL编码-解码"><a href="#URL编码-解码" class="headerlink" title="URL编码/解码"></a>URL编码/解码</h3><p>查询字符串:urlencode/urldecode,因为HTTP中参数出以&lt;key,val&gt;组成键值对,以&amp;连接</p><p>像 / ? : 等这样的字符, 已经被url当做特殊意义理解了. 因此这些字符不能随意出现. 比如, 某个参数中需要带有这些特殊字符, 就必须先对特殊字符进行转义.<br>转义的规则如下:  将需要转码的字符转为16进制，然后从右到左，取4位(不足4位直接处理)，每2位做一位，前面加上%，编码成%XY 格式</p><p>课后调研实现urlencode/urldecode</p><a id="more"></a><h3 id="HTPP协议格式"><a href="#HTPP协议格式" class="headerlink" title="HTPP协议格式"></a>HTPP协议格式</h3><h4 id="HTTP的三大部分-首行-头部-正文"><a href="#HTTP的三大部分-首行-头部-正文" class="headerlink" title="HTTP的三大部分:首行,头部,正文"></a>HTTP的三大部分:首行,头部,正文</h4><h5 id="请求消息格式"><a href="#请求消息格式" class="headerlink" title="请求消息格式"></a>请求消息格式</h5><p><img src="D:\MyBlog\source\images\http协议格式.webp" alt=""></p><h5 id="首行-请求首行-相应首行"><a href="#首行-请求首行-相应首行" class="headerlink" title="首行:请求首行,相应首行"></a>首行:请求首行,相应首行</h5><h5 id="请求首行-请求方法-GET-POST-HEAD-PUT-DELETE-HTTP协议版本-0-9-1-0-1-1-2-0"><a href="#请求首行-请求方法-GET-POST-HEAD-PUT-DELETE-HTTP协议版本-0-9-1-0-1-1-2-0" class="headerlink" title="请求首行:请求方法(GET/POST/HEAD/PUT/DELETE) HTTP协议版本(0.9/1.0/1.1/2.0)"></a>请求首行:请求方法(GET/POST/HEAD/PUT/DELETE) HTTP协议版本(0.9/1.0/1.1/2.0)</h5><h5 id="头部-一-请求的属性-冒号分割的键值对-每组属性之间使用-n分隔-遇到空行表示Header部分结束"><a href="#头部-一-请求的属性-冒号分割的键值对-每组属性之间使用-n分隔-遇到空行表示Header部分结束" class="headerlink" title="头部:一 请求的属性, 冒号分割的键值对;每组属性之间使用\n分隔;遇到空行表示Header部分结束"></a>头部:一 请求的属性, 冒号分割的键值对;每组属性之间使用\n分隔;遇到空行表示Header部分结束</h5><p>key: val\r\n key: val\r\n</p><p><strong>常见的请求方法 </strong></p><ul><li><p>GET方法:请求指定的页面信息，并返回实体主体</p></li><li><p>POST方法:向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。</p></li><li><p>PUT:从客户端向服务器传送的数据取代指定的文档的内容</p></li></ul><h4 id="GET-POST区别-get无正文-post有正文"><a href="#GET-POST区别-get无正文-post有正文" class="headerlink" title="GET/POST区别:get无正文 post有正文"></a><strong>GET/POST区别:get无正文 post有正文</strong></h4><p>1.请求参数的区别</p><p><code>GET</code>请求会把请求的参数拼接在<code>URL</code>后面，以<code>?</code>分隔，多个参数之间用<code>&amp;</code>连接；如果是英文或数字，原样发送，如果是空格或中文，则用<a href="https://link.jianshu.com?t=https://segmentfault.com/a/1190000004533485?_ea=657625" target="_blank" rel="noopener">Base64</a>编码</p><p><code>POST</code>请求会把提交的数据放在请求体中，不会在<code>URL</code>中显示出来</p><p>2.传输数据的大小</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET`: 浏览器和服务器会限制`URL`的长度，所以传输的数据有限，一般是<span class="number">2</span>K</span><br></pre></td></tr></table></figure><p><code>POST</code>: 由于数据不是通过<code>URL</code>传递，所以一般可以传输较大量的数据</p><p>3.数据解析</p><p><code>GET</code>: 通过<code>Request.QueryString</code>获取变量的值</p><p><code>POST</code>: 通过<code>Request.form</code>获取变量的值</p><p>4.安全性</p><p><code>GET</code>: 请求参数在<code>URL</code>后面，可以直接看到，尤其是登录时，如果登录界面被浏览器缓存，其他人就可以通过查看历史记录，拿到账户和密码</p><p><code>POST</code>: 请求参数在请求体里面传输，无法直接拿到，相对<code>GET</code>安全性较高；但是通过抓包工具，还是可以看到请求参数的</p><h4 id="HTTP-0-9-1-0-1-1-2-0区别"><a href="#HTTP-0-9-1-0-1-1-2-0区别" class="headerlink" title="HTTP 0.9/1.0/1.1/2.0区别"></a>HTTP 0.9/1.0/1.1/2.0区别</h4><p><strong>HTTP 0.9 ：</strong></p><ul><li>只接受GET一种请求方法，没有在通信中指定版本号，且不支持请求头；</li><li>此外该版本也不支持POST方法，因此客户端无法向服务器传递太多信息；</li><li>短连接</li></ul><p><strong>HTTP 1.0：</strong></p><ul><li>支持POST、GET、HEAD三种方法；</li><li>规定浏览器与服务器之间只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求；</li></ul><p><strong>HTTP 1.1：</strong></p><ul><li><p>新增了五种请求方法：PUT、DELETE、CONNECT、TRACE、OPTIONS；</p></li><li><p>HTTP 1.1 在Request消息头里头多了一个Host域，便于一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点；</p></li><li>在HTTP/1.1中新增了24个状态响应码：<br>100-199 用于指定客户端应相应的某些动作。<br>200-299 用于表示请求成功。<br>300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。<br>400-499 用于指出客户端的错误。<br>500-599 用于支持服务器错误。</li></ul><p><strong>HTTP2.0：</strong></p><ul><li><p>HTTP2.0使用多路复用技术(Multiplexing),多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。”HTTP1.1在同一时间对于同一个域名的请求数量有限制，超过限制就会阻塞请求”。多路复用底层采用”增加二进制分帧层”的方法，使得不改变原来的语义、首部字段的情况下提高传输性能，降低延迟。二进制分帧将所有传输信息分割为更小的帧，用二进制进行编码，多个请求都在同一个TCP连接上完成，可以承载任意数量的双向数据流。HTTP/2更有效的使用TCP连接，得到性能上的提升</p><p><strong>详解：</strong></p><p>[<a href="https://www.jianshu.com/p/ac628fda40f2?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation]" target="_blank" rel="noopener">https://www.jianshu.com/p/ac628fda40f2?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation]</a>: </p></li></ul><h5 id="正文"><a href="#正文" class="headerlink" title="正文:"></a>正文:</h5><p>空行后面的内容都是Body. Body允许为空字符串. 如果Body存在, 则在Header中会有一个 </p><p>Content-Length属性来标识Body的长度;</p><h5 id="响应消息格式"><a href="#响应消息格式" class="headerlink" title="响应消息格式"></a>响应消息格式</h5><p>响应首行: [版本号] + [状态码] + [状态码解释] </p><p>Header: 请求的属性, 冒号分割的键值对;每组属性之间使用\n分隔;遇到空行表示Header部分结束 </p><p>Body: 空行后面的内容都是Body. Body允许为空字符串. 如果Body存在, 则在Header中会有一个 </p><p>Content-Length属性来标识Body的长度; 如果服务器返回了一个html页面, 那么html页面内容就是在 </p><p>body中.  </p><h5 id="常见响应头"><a href="#常见响应头" class="headerlink" title="常见响应头"></a>常见响应头</h5><p>Content-Type: 数据类型(text/html等) </p><p>Content-Length: Body的长度 </p><p>Host: 客户端告知服务器, 所请求的资源是在哪个主机的哪个端口上; </p><p>User-Agent: 声明用户的操作系统和浏览器版本信息; </p><p>referer: 当前页面是从哪个页面跳转过来的; </p><p>location: 搭配3xx状态码使用, 告诉客户端接下来要去哪里访问; </p><p>Cookie: 用于在客户端存储少量信息. 通常用于实现会话(session)的功能;  </p><h5 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h5><p>HTTP协议的状态码由3位数字组成，第一个数字定义了响应的类别，共有5中类别：</p><ul><li>1xx: 指示信息–表示请求已接收，继续处理</li><li>2xx: 成功–表示请求已被成功接收、理解、接受</li><li>3xx: 重定向–要完成请求必须进行更进一步的操作</li><li>4xx: 客户端错误–请求有语法错误或请求无法实现</li><li>5xx: 服务器端错误–服务器未能实现合法的请求</li></ul><p>常见状态码:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">200 </span>OK                        //客户端请求成功</span><br><span class="line"><span class="symbol">400 </span>Bad Request               //客户端请求有语法错误，不能被服务器所理解</span><br><span class="line"><span class="symbol">401 </span>Unauthorized              //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 </span><br><span class="line"><span class="symbol">403 </span>Forbidden                 //服务器收到请求，但是拒绝提供服务</span><br><span class="line"><span class="symbol">404 </span><span class="keyword">Not</span> Found                 //请求资源不存在，eg：输入了错误的URL</span><br><span class="line"><span class="symbol">500 </span>Internal Server <span class="keyword">Error</span>     //服务器发生不可预期的错误</span><br><span class="line"><span class="symbol">503 </span>Server Unavailable        //服务器当前不能处理客户端的请求，一段时间后可能恢复正常</span><br></pre></td></tr></table></figure><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><code>HTTP</code>协议采用请求/响应模式，客户端向服务器发送一个请求报文，然后服务器响应请求。下面介绍一下一次<code>HTTP</code>请求的过程：</p><ol><li>在浏览器中输入<code>URL</code>，并按下回车键</li><li>浏览器向<code>DNS</code>服务器请求解析该<code>URL</code>中的域名对应的<code>IP</code>地址(如果是<code>IP</code>请求，则不需要该步骤)</li><li>解析出<code>IP</code>后，根据<code>IP</code>和端口号，和服务器建立<a href="https://www.jianshu.com/p/ef892323e68f" target="_blank" rel="noopener">TCP</a>连接</li><li>浏览器向服务器发送请求，该请求报文作为<code>TCP</code>三次握手的第三个报文发送给服务器</li><li>服务器做出响应，把数据发送给浏览器</li><li>通信完成，断开<code>TCP</code>连接</li><li>浏览器解析收到的数据并显示</li></ol><h3 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h3><p><code>HTTPS</code>是安全的<code>HTTP</code>通道，即在HTTP通信中加入了<code>SSL</code>层（当前版本是<code>TLS1.2</code>），通信的数据被加密了，防止被窃取，具体的通信流程如下：</p><p><img src="D:\MyBlog\source\images\HTTPS.png" alt=""></p><p>HTTPS使用的加密方式结合了对称加密和不对称加密的特点，在保证安全的情况下，又提高了传输效率。HTTP和HTTPS的区别如下：</p><p>1.https协议需要到ca申请证书，一般免费证书很少，需要交费。</p><p>2.http的信息是明文传输，https 则是具有安全性的ssl加密传输协议。</p><p>3.http和https用的端口不一样，前者是80，后者是443。</p><p>4.http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全</p><h4 id="https通信流程"><a href="#https通信流程" class="headerlink" title="https通信流程"></a>https通信流程</h4><p><strong>HTTPS在传输的过程中会涉及到三个密钥：</strong></p><p>服务器端的公钥和私钥，用来进行非对称加密</p><p>客户端生成的随机密钥，用来进行对称加密</p><p>一个HTTPS请求实际上包含了两次HTTP传输，可以细分为8步。<br>1.客户端向服务器发起HTTPS请求，连接到服务器的443端口</p><p>2.服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。</p><p>3.服务器将自己的公钥发送给客户端。</p><p>4.客户端收到服务器端的公钥之后，会对公钥进行检查，验证其合法性，如果发现发现公钥有问题，那么HTTPS传输就无法继续。严格的说，这里应该是验证服务器发送的数字证书的合法性，关于客户端如何验证数字证书的合法性，下文会进行说明。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。</p><p>5.客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。</p><p>6.服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。</p><p>7.然后服务器将加密后的密文发送给客户端。</p><p>8.客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作符总结</title>
      <link href="/2019/01/22/%E6%93%8D%E4%BD%9C%E7%AC%A6%E6%80%BB%E7%BB%93/"/>
      <url>/2019/01/22/%E6%93%8D%E4%BD%9C%E7%AC%A6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>同一优先级的运算符，结合次序由结合方向所决定。<br>简单记就是：！ &gt; 算术运算符 &gt; 关系运算符 &gt; &amp;&amp; &gt; || &gt; 赋值运算符<br><a id="more"></a></p><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p><strong>1.算数操作符:+,-,/,*,%</strong><br>这部分只需注意/,%的除数不可以为零,模运算只能是整型<br><strong>2.移位操作符:&lt;&lt;,&gt;&gt;</strong><br>移位的规则:左移操作:左边抛弃右边补零<br>                   右移操作:逻辑右移:左边用0填充,右边丢弃<br>                                  算数右移:左边用符号位填充,右边丢弃<br> 这里还需要注意位移操作符的对象是整型,进行操作时要考虑是否越界,移位的值必须非负,                               <img src="https://img-blog.csdnimg.cn/20190122155923779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4ODMzMjU3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>标准说明无符号值进行所有移位操作都是逻辑移位,有符号值取决于编译器</p></blockquote><p>所以不建议使用移位操作这样程序的可移植性差<br><strong>位操作:&amp;,|,^</strong><br>操作数必须为整数<br>下面是常见的的使用场景:<br>1)给指定位赋1或0<br>2)一个数中1的个数<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> GetoneCount(<span class="built_in">int</span> <span class="keyword">number</span>) &#123;</span><br><span class="line">true<span class="built_in">int</span> <span class="built_in">count</span> = <span class="number">0</span>;</span><br><span class="line">truefor (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">32</span>; ++i) &#123;</span><br><span class="line">truetrue<span class="keyword">if</span> (<span class="keyword">number</span>&amp;(<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">truetruetrue<span class="built_in">count</span>++;</span><br><span class="line">true&#125;</span><br><span class="line">true<span class="keyword">return</span> <span class="built_in">count</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>求补和逗号操作符</strong><br>1.逗号表达式的值为从左到右最后一个<br> <strong>关系操作符</strong><br> 1.其结果值得类型为整型<br> 2.=,==是不同的<br> 在C语言中=为赋值 ==为比较<br> <strong>逻辑操作符</strong><br> 1.短路求值先左再右<br> 2.&amp;,&amp;&amp;,|,||的区别<br> 逻辑操作用于测试0值和非0值而位操作用于比较操作数中对应的位<br><strong>左值和右值</strong><br>左值标识了一个储存结果值的地点,标识了一个特定的位置,字面值常量也都不是左值<br>这个地址指的是程序员可以获得的<br><strong>操作符的优先级和求值顺序</strong><br> 同一优先级的运算符，结合次序由结合方向所决定。<br>简单记就是：！ &gt; 算术运算符 &gt; 关系运算符 &gt; &amp;&amp; &gt; || &gt; 赋值运算符</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言总结 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
