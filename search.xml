<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++多态</title>
      <link href="/2019/08/16/C-%E5%A4%9A%E6%80%81/"/>
      <url>/2019/08/16/C-%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h1 id="C-多态"><a href="#C-多态" class="headerlink" title="C++多态"></a>C++多态</h1><p><strong>概念</strong>:多态的概念：通俗来说，就是多种形态，<strong>具体点就是去完成某个行为，当不同的对象去完成时会产生出不同</strong> </p><p><strong>的状态</strong>。举个栗子：比如<strong>买票这个行为</strong>，当<strong>普通人</strong>买票时，是全价买票；<strong>学生</strong>买票时，是半价买票；<strong>军人</strong>买票时是优 先买票。 </p><a id="more"></a><h4 id="多态的定义和实现"><a href="#多态的定义和实现" class="headerlink" title="多态的定义和实现"></a>多态的定义和实现</h4><h5 id="多态的构成条件"><a href="#多态的构成条件" class="headerlink" title="多态的构成条件:"></a>多态的构成条件:</h5><p>不同对象调用同一函数产生了不同的行为。那么在继承中要<strong>构成多态还有两个条件</strong>： </p><ol><li><p>必须通过基类的指针或者引用调用虚函数 （基类指针引用指向派生类对象才是安全的）</p></li><li><p>被调用的函数必须是虚函数，且派生类必须对基类的虚函数进行重写 </p></li></ol><p><img src="D:\MyBlog\source\images\多态.png" alt=""></p><h5 id="虚函数：即被vitrual修饰的成员函数我们称之为虚函数。"><a href="#虚函数：即被vitrual修饰的成员函数我们称之为虚函数。" class="headerlink" title="虚函数：即被vitrual修饰的成员函数我们称之为虚函数。"></a>虚函数：即被vitrual修饰的成员函数我们称之为虚函数。</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">true<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuyTicket</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">truetrue<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"success"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">true&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="虚函数的重写"><a href="#虚函数的重写" class="headerlink" title="虚函数的重写"></a>虚函数的重写</h5><p>虚函数的重写(覆盖)：<strong>派生类中有一个跟基类完全相同的虚函数</strong>（即派生类虚函数与基类虚函数的返回值类型、函数名字、参数列表完全相同)，称子类的虚函数重写了基类的虚函数。</p><p>注意：</p><pre><code>在重写基类虚函数时，派生类的虚函数在不加virtual关键字时，虽然也可以构成重写(因为继承后基类的虚函数被继承下来了在派生类依旧保持虚函数属性),但是该种写法不是很规范，不建议这样使用</code></pre><h5 id="虚函数重写的两个例外："><a href="#虚函数重写的两个例外：" class="headerlink" title="虚函数重写的两个例外："></a>虚函数重写的两个例外：</h5><h6 id="1-协变"><a href="#1-协变" class="headerlink" title="1.协变"></a>1.协变</h6><p>派生类重写基类虚函数时，与基类虚函数返回值类型不同。即基类虚函数返回基类对象的指针或者引 </p><p>用，派生类虚函数返回派生类对象的指针或引用时称为协变</p><h6 id="2-析构函数的重写（基类与派生类析构函数的名字不同"><a href="#2-析构函数的重写（基类与派生类析构函数的名字不同" class="headerlink" title="2. 析构函数的重写（基类与派生类析构函数的名字不同)"></a>2. 析构函数的重写（基类与派生类析构函数的名字不同)</h6><p>如果基类的析构函数为虚函数，此时派生类析构函数只要定义，<strong>无论是否加virtual关键字，都与基类的</strong> </p><p><strong>析构函数构成重写</strong>，虽然基类与派生类析构函数名字不同。虽然函数名不相同，看起来违背了重写的规 </p><p>则，其实不然，这里可以理解为编译器对析构函数的名称做了特殊处理，<strong>编译后析构函数的名称统一</strong>处 </p><p>理成<strong>destructor</strong>。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~Person() &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~Person()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~Student() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Student()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person* p1 = <span class="keyword">new</span> Person;</span><br><span class="line">Person* p2 = <span class="keyword">new</span> Student;</span><br><span class="line"><span class="keyword">delete</span> p1;</span><br><span class="line"><span class="keyword">delete</span> p2;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>只有派生类Student的析构函数重写了Person的析构函数，下面的delete对象调用析构函数，才能构成 </p><p>多态，才能保证p1和p2指向的对象正确的调用析构函数。</p><h5 id="C-11-override和-final"><a href="#C-11-override和-final" class="headerlink" title="C++11 override和 final"></a>C++11 override和 final</h5><ol><li><strong>final：修饰虚函数，表示该虚函数不能再被继承</strong></li><li><strong>override:</strong> <strong>检查派生类虚函数是否重写了基类某个虚函数，如果没有重写编译报错。</strong></li></ol><h5 id="重载，覆盖（重写），隐藏（重定义）的区别"><a href="#重载，覆盖（重写），隐藏（重定义）的区别" class="headerlink" title="重载，覆盖（重写），隐藏（重定义）的区别"></a>重载，覆盖（重写），隐藏（重定义）的区别</h5><p><img src="D:\MyBlog\source\images\隐藏重写重载.png" alt=""></p><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>在虚函数的后面写上 =0 ，则这个函数为纯虚函数。<strong>包含纯虚函数的类叫做抽象类（也叫接口类），抽象类</strong> </p><p><strong>不能实例化出对象</strong>。派生类继承后也不能实例化出对象，只有重写纯虚函数，派生类才能实例化出对象。纯 </p><p>虚函数规范了派生类必须重写，另外纯虚函数更体现出了接口继承。</p><p><strong>接口继承和现实继承</strong>：</p><p>普通函数的继承是一种实现继承，<strong>派生类继承了基类函数，可以使用函数，继承的是函数的实现</strong>。虚函数的 </p><p>继承是一种接口继承，派生类继承的是基类虚函数的接口，目的是为了重写，达成多态，继承的是接口。所 </p><p>以如果不实现多态，不要把函数定义成虚函数。</p><h4 id="多态实现的原理"><a href="#多态实现的原理" class="headerlink" title="多态实现的原理"></a>多态实现的原理</h4><h5 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> &#123;</span></span><br><span class="line">true<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">truetrue<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"haa"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">true&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">true<span class="keyword">int</span> _test;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过观察测试我们发现test类是8bytes，除了成员变量_test，还多一个vfptr放在对象的前面(注意有些平台可能会放到对象的最后面，这个跟平台有关),对象中的这个指针我们叫做虚函数表指针(v代表virtual，f代表function)。一个含有虚函数的类中都至少都有一个虚函数表指针，因为虚函数的地址要被放到虚函数表中， 虚函数表也简称虚表。</p><p><img src="D:\MyBlog\source\images\虚表指针.png" alt=""></p><p><strong>补充</strong>：</p><p>1.虚函数表本质是一个存<strong>虚函数指针的指针数组</strong>，这个数组最后面放了一个nullptr。</p><p>2.派生类的虚表生成：</p><p>a.先将基类中的虚表内容拷贝一份到派生类虚表中</p><p> b.如果派生类重写了基类中某个虚函数，用派生类自己的虚函数覆盖虚表中基类的虚函数 </p><p> c.派生类自己新增加的虚函数按其在派生类中的声明次序增加到派生类虚表的最后。</p><p><img src="D:\MyBlog\source\images\虚表指针内容.png" alt=""></p><p><strong>注意</strong></p><p><strong>虚表存的是虚函数指针，不是虚函数</strong>，虚函数和普通函数一样的，都是存在<strong>代码段的</strong>，只是他的指针又存到了虚表中。另外 对象中存的不是虚表，存的是虚表指针。</p><h5 id="多态实现的原理-1"><a href="#多态实现的原理-1" class="headerlink" title="多态实现的原理"></a>多态实现的原理</h5><ol><li>基类对象和派生类对象调用虚函数时在虚表中找的函数是不一样的。</li><li>这样就实现出了不同对象去完成同一行为时，展现出不同的形态。 </li><li>反过来思考我们要达到多态，有两个条件，一个是虚函数覆盖，一个是基类对象的指针或引用调用虚函数。 反思一下为什么？因为基类指针指向派生类对象是安全的 而派生类指向基类的地址是放大了范围是不安全的。</li><li><strong>满足多态以后的函数调用，不是在编译时确定的，是运行起来以后到对象的中取找的。不满足多态的函数调  用时编译时确认好的</strong></li></ol><h5 id="动态绑定与静态绑定"><a href="#动态绑定与静态绑定" class="headerlink" title="动态绑定与静态绑定"></a>动态绑定与静态绑定</h5><ol><li><p>静态绑定又称为前期绑定(早绑定 )，<strong>在程序编译期间确定了程序的行为</strong>，<strong>也称为静态多态</strong>，比如：函数重载 </p></li><li><p>动态绑定又称后期绑定(晚绑定)，是在程序运行期间，根据具体拿到的类型确定程序的具体行为，调用 具体的函数，<strong>也称为动态多态</strong>。  </p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++类和对象</title>
      <link href="/2019/08/15/C-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
      <url>/2019/08/15/C-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>   C++编译器不允许对象为零长度。试想一个长度为0的对象在内存中怎么存放？怎么获取它的地址？为了避免这种情况，C++强制给这种类插入一个缺省成员，长度为1。如果有自定义的变量，变量将取代这个缺省成员。</p><a id="more"></a><h1 id="C-类的初识"><a href="#C-类的初识" class="headerlink" title="C++类的初识"></a>C++类的初识</h1><h2 id="什么是类"><a href="#什么是类" class="headerlink" title="什么是类"></a>什么是类</h2><p>类就是对事物特征的抽象,也可以理解为一个模具,不是他所描述的具体的事物.c++中引入类也引入了一种新的编程思维,传统C语言是面向过程的我们解决问题时关注的时解决问题的步骤具体体现为函数,而面向对象编程关注的是对象的行为和对象间的交互</p><h2 id="类的引入和定义"><a href="#类的引入和定义" class="headerlink" title="类的引入和定义"></a>类的引入和定义</h2><p>C++中可以用struct 和 class定义类,区别是struct的成员默认访问方式是public，class是struct的成员默认访问方式 是private。</p><p>class为定义类的关键字，ClassName为类的名字，{}中为类的主体，注意类定义结束时后面分号。 类中的元素称为类的成员：类中的数据称为类的属性或者成员变量; 类中的函数称为类的方法或者成员函数。<br>类的两种定义方式：</p><ol><li>声明和定义全部放在类体中，需要注意：成员函数如果在类中定义，编译器可能会将其当成内联函数处 理。</li><li>声明放在.h文件中，类的定义放在.cpp文件中</li></ol><h2 id="类的访问限定符及封装"><a href="#类的访问限定符及封装" class="headerlink" title="类的访问限定符及封装"></a>类的访问限定符及封装</h2><h3 id="C-实现封装的方式"><a href="#C-实现封装的方式" class="headerlink" title="C++实现封装的方式"></a>C++实现封装的方式</h3><p>用类将对象的属性与方法结合在一块让对象更加完善，通过访问权限选择性的将其 接口提供给外部的用户使用。</p><h3 id="访问限定符的说明"><a href="#访问限定符的说明" class="headerlink" title="访问限定符的说明"></a>访问限定符的说明</h3><ol><li>public修饰的成员在类外可以直接被访问 </li><li>protected和private修饰的成员在类外不能直接被访问(此处protected和private是类似的) </li><li>访问权限作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止 </li><li>class的默认访问权限为private，struct为public(因为struct要兼容C)</li></ol><p>注意：访问限定符只在编译时有用，当数据映射到内存后，没有任何访问限定符上的区别</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装:"></a>封装:</h3><p>将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行 交互。</p><p>封装本质上是一种管理：我们如何管理兵马俑呢？比如如果什么都不管，兵马俑就被随意破坏了。那么我们 首先建了一座房子把兵马俑给封装起来。但是我们目的全封装起来，不让别人看。所以我们开放了售票通 道，可以买票突破封装在合理的监管机制下进去参观。类也是一样，我们使用类数据和方法都封装到一下。 不想给别人看到的，我们使用protected/private把成员封装起来。开放一些共有的成员函数对成员合理的访 问。所以封装本质是一种管理。 </p><h3 id="友元"><a href="#友元" class="headerlink" title="友元 :"></a>友元 :</h3><p><strong>友元分为</strong>：友元函数和友元类</p><p>友元提供了一种突破封装的方式，有时提供了便利。但是友元会增加耦合度，破坏了封装，所以友元不宜多用。</p><h4 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h4><p>友元函数可以直接访问类的私有成员，它是定义在类外部的普通函数，不属于任何类，但需要在类的内部声 明，声明时需要加friend关键字。</p><p><strong>注意:</strong></p><p>友元函数可访问类的私有成员，但不是类的成员函数 </p><p>友元函数不能用const修饰 </p><p>友元函数可以在类定义的任何地方声明，不受类访问限定符限制 一个函数可以是多个类的友元函数 </p><p>友元函数的调用与普通函数的调用和原理相同</p><h4 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h4><p>友元类的所有成员函数都可以是另一个类的友元函数，都可以访问另一个类中的非公有成员。<br>友元关系是单向的，不具有交换性。 比如上述Time类和Date类，在Time类中声明Date类为其友元类，那么可以在Date类中直接访问Time 类的私有成员变量，但想在Time类中访问Date类中私有的成员变量则不行。 </p><p>友元关系不能传递 如果B是A的友元，C是B的友元，则不能说明C时A的友元。</p><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><h4 id="概念及特性"><a href="#概念及特性" class="headerlink" title="概念及特性"></a>概念及特性</h4><p>概念：如果一个类定义在另一个类的内部，这个内部类就叫做内部类。注意此时这个内部类是一个独立的 类，它不属于外部类，更不能通过外部类的对象去调用内部类。外部类对内部类没有任何优越的访问权限。<br>注意：内部类就是外部类的友元类。注意友元类的定义，内部类可以通过外部类的对象参数来访问外部类中 的所有成员。但是外部类不是内部类的友元。<br>特性：</p><ol><li>内部类可以定义在外部类的public、protected、private都是可以的。 </li><li>注意内部类可以直接访问外部类中的static、枚举成员，不需要外部类的对象/类名。 </li><li>sizeof(外部类)=外部类，和内部类没有任何关系。</li></ol><h3 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域:"></a>类的作用域:</h3><p>类定义了一个新的作用域，类的所有成员都在类的作用域中。在类体外定义成员，需要使用 :: 作用域解析符指明成员属于哪个类域。</p><h3 id="类的实例化"><a href="#类的实例化" class="headerlink" title="类的实例化:"></a>类的实例化:</h3><ol><li>类只是一个模型一样的东西，限定了类有哪些成员，定义出一个类并没有分配实际的内存空间来存储它 </li><li>一个类可以实例化出多个对象，实例化出的对象  占用实际的物理空间，存储类成员变量 做个比方。类实例化出对象就像现实中使用建筑设计图建造出房子，类就像是设计图，只设计出需要什么东西，但是并没有实体的建筑存在，同样类也只是一个设计，<strong>实例化出的对象才能实际存储数据，占用物理空间</strong></li></ol><h4 id="类大小的计算"><a href="#类大小的计算" class="headerlink" title="类大小的计算:"></a>类大小的计算:</h4><h5 id="类的存储方式"><a href="#类的存储方式" class="headerlink" title="类的存储方式"></a>类的存储方式</h5><p>只保存成员变量，成员函数存放在公共的代码段 </p><h5 id="计算规则"><a href="#计算规则" class="headerlink" title="计算规则"></a>计算规则</h5><p>一个类的大小，实际就是该类中”成员变量”之和，当然也要进行内存对齐，注意空类的大小，空类比 较特殊，编译器给了空类一个字节来唯一标识这个类。</p><p><strong>空类的大小为什么是1?</strong></p><pre><code>C++编译器不允许对象为零长度。试想一个长度为0的对象在内存中怎么存放？怎么获取它的地址？为了避免这种情况，C++强制给这种类插入一个缺省成员，长度为1。如果有自定义的变量，变量将取代这个缺省成员。</code></pre><h4 id="结构体大小的计算——-内存对齐"><a href="#结构体大小的计算——-内存对齐" class="headerlink" title="结构体大小的计算——-内存对齐"></a>结构体大小的计算——-内存对齐</h4><ol><li>第一个成员在与结构体偏移量为0的地址处。 </li><li>其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。 注意：对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值。 VS中默认的对齐数为8，gcc中的对齐数为4 </li><li>结构体总大小为：最大对齐数（所有变量类型最大者与默认对齐参数取最小）的整数倍。 </li><li>如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是 所有最大对齐数（含嵌套结构体的对齐数）的整数倍。</li></ol><h2 id="一些更加深入的的讨论"><a href="#一些更加深入的的讨论" class="headerlink" title="一些更加深入的的讨论"></a>一些更加深入的的讨论</h2><h3 id="为什么要内存对齐"><a href="#为什么要内存对齐" class="headerlink" title="为什么要内存对齐?"></a>为什么要内存对齐?</h3><p>现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。</p><p>对齐的作用和原因：各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问一个没有进行对齐的变量的时候会发生错误,那么在这种架构下编程必须保证字节对齐.其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。显然在读取效率上下降很多。</p><p><strong>如何让结构体按照指定的对齐参数进行对齐</strong> </p><p>#pragma pack (2)</p><h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><ol><li>this指针的类型：类类型* const 2. </li><li>只能在“成员函数”的内部使用 </li><li>this指针本质上其实是一个成员函数的形参，是对象调用成员函数时，将对象地址作为实参传递给this 形参。所以对象中不存储this指针。</li><li>this指针是成员函数第一个隐含的指针形参，一般情况由编译器通过ecx寄存器自动传递，不需要用户 传递</li><li>this指针存放在栈上</li></ol><h3 id="this指针存在哪里？"><a href="#this指针存在哪里？" class="headerlink" title="this指针存在哪里？"></a>this指针存在哪里？</h3><p>其实编译器在生成程序时加入了获取对象首地址的相关代码。并把获取的首地址存放在了寄存器ECX中(VC++编译器是放在ECX中，其它编译器有可能不同)。也就是成员函数的其它参数正常都是存放在栈中。而this指针参数则是存放在寄存器中。类的静态成员函数因为没有this指针这个参数，所以类的静态成员函数也就无法调用类的非静态成员变量。</p><h3 id="this指针可以为空吗？"><a href="#this指针可以为空吗？" class="headerlink" title="this指针可以为空吗？"></a>this指针可以为空吗？</h3><p>可以为空，当我们在调用函数的时候，如果函数内部并不需要使用到this,也就是不需要通过this指向当前对象并对其进行操作时才可以为空(当我们在其中什么都不放或者在里面随便打印一个字符串)，如果调用的函数需要指向当前对象，并进行操作，则会发生错误（空指针引用）就跟C中一样不能进行空指针的引用</p><h2 id="类的六类默认函数"><a href="#类的六类默认函数" class="headerlink" title="类的六类默认函数"></a>类的六类默认函数</h2><p>如果一个类中什么成员都没有，简称为空类。空类中什么都没有吗？并不是的，任何一个类在我们不写的情 况下，都会自动生成下面6个默认成员函数。</p><p><strong>构造函数,析构函数,拷贝构造函数,赋值重载,const成员函数,取地址及const取地址操作符重载</strong> </p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p><strong>概念:</strong>构造函数是一个特殊的成员函数，<strong>名字与类名相同,创建类类型对象时由编译器自动调用，</strong>保证每个数据成员 都有 一个合适的初始值，<strong>并且在对象的生命周期内只调用一次</strong>。</p><p><strong>特性:</strong>构造函数是特殊的成员函数，需要注意的是，构造函数的虽然名称叫构造，但是需要注意的是构造函数的主 要任务并<strong>不是开空间创建对象，而是初始化对象</strong>。</p><h5 id="构造函数主要特征"><a href="#构造函数主要特征" class="headerlink" title="构造函数主要特征"></a>构造函数主要特征</h5><p>函数名与类名相同。 </p><p>无返回值。 </p><p>对象实例化时编译器自动调用对应的构造函数。</p><p>构造函数可以重载。</p><p>如果类中没有显式定义构造函数，则C++编译器会自动生成一个无参的默认构造函数，一旦用户显式定 义编译器将不再生成</p><p>无参的构造函数和全缺省的构造函数都称为默认构造函数，并且默认构造函数只能有一个。注意：无参 构造函数、全缺省构造函数、我们没写编译器默认生成的构造函数，都可以认为是默认成员函数。</p><p>C++把类型分成内置类型(基本类型)和自定义类型。内置类型就是语法已经定义好的类型：如 int/char…，自定义类型就是我们使用class/struct/union自己定义的类型, 编译器生成默认的构造函数会对自定类型成员_t调用的它的默认成员函数</p><h5 id="构造函数体赋值"><a href="#构造函数体赋值" class="headerlink" title="构造函数体赋值"></a>构造函数体赋值</h5><p>构造函数体赋值不能称作初始化因为初始化只有一次即在对象创建的时候,构造函数体可以多次赋值所以之=只能叫赋初值</p><h5 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h5><p>初始化列表：以一个冒号开始，接着是一个以逗号分隔的数据成员列表，每个”成员变量”后面跟一个放在括 号中的初始值或表达式。</p><p>​    </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">class</span> <span class="selector-tag">A</span> &#123;</span><br><span class="line"><span class="attribute">public</span>:</span><br><span class="line">true<span class="built_in">A</span>(int a,int b,int c)</span><br><span class="line">truetrue:<span class="built_in">_a</span>(a)</span><br><span class="line">truetrue,<span class="built_in">_b</span>(b)</span><br><span class="line">truetrue,<span class="built_in">_c</span>(c)</span><br><span class="line">true&#123;&#125;</span><br><span class="line"><span class="selector-tag">private</span>:</span><br><span class="line">true<span class="selector-tag">int</span> _<span class="selector-tag">a</span>;</span><br><span class="line">true<span class="selector-tag">int</span> _<span class="selector-tag">b</span>;</span><br><span class="line">true<span class="selector-tag">int</span> _<span class="selector-tag">c</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><p>每个成员变量在初始化列表中只能出现一次(初始化只能初始化一次) </p><p>  类中包含以下成员，必须放在初始化列表位置进行初始化：</p><p>  引用成员变量 </p><p>  const成员变量 </p><p>类类型成员(该类没有默认构造函数)</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:   </span><br><span class="line">trueB(<span class="keyword">int</span> a, <span class="keyword">int</span> <span class="keyword">ref</span>)</span><br><span class="line">true:_aobj(a)</span><br><span class="line">    , _ref(<span class="keyword">ref</span>)</span><br><span class="line">    , _n(<span class="number">10</span>)</span><br><span class="line">true&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">trueA _aobj;      <span class="comment">// 没有默认构造函数 </span></span><br><span class="line">true<span class="keyword">int</span>&amp; _ref;    <span class="comment">// 引用   </span></span><br><span class="line">true<span class="keyword">const</span> <span class="keyword">int</span> _n; <span class="comment">// const</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 尽量使用初始化列表初始化，因为不管你是否使用初始化列表，对于自定义类型成员变量，一定会先使 用初始化列表初始化。</p><p>成员变量在类中声明次序就是其在初始化列表中的初始化顺序，与其在初始化列表中的先后次序无关</p><p><strong>用explicit修饰构造函数，将会禁止单参构造函数的隐式转换。</strong></p><h5 id="static成员"><a href="#static成员" class="headerlink" title="static成员"></a><strong>static成员</strong></h5><p>声明为static的类成员称为类的静态成员，用static修饰的成员变量，称之为静态成员变量；用static修饰的 成员函数，称之为静态成员函数。静态的成员变量一定要在类外进行初始化</p><p>特点:</p><ol><li><p>静态成员为所有类对象所共享，不属于某个具体的实例</p></li><li><p>静态成员变量必须在类外定义，定义时不添加static关键字 </p></li><li><p>类静态成员即可用类名::静态成员或者对象.静态成员来访问 </p></li><li><p>静态成员函数没有隐藏的this指针，不能访问任何非静态成员 </p></li><li><p>静态成员和类的普通成员一样，也有public、protected、private3种访问级别，也可以具有返回值， const修饰符等参数</p><p>C++11支持非静态的成员变量直接初始化</p></li></ol><h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><p><strong>概念</strong>：与构造函数功能相反，析构函数不是完成对象的销毁，局部对象销毁工作是由编译器完成的。而对象在销毁时会自动调用析构函数，完成类的一些资源清理工作。</p><p>析构函数特征：</p><ol><li>析构函数名是在类名前加上字符 ~。 </li><li>无参数无返回值。 </li><li>一个类有且只有一个析构函数。若未显式定义，系统会自动生成默认的析构函数。 </li><li>对象生命周期结束时，C++编译系统系统自动调用析构函数。</li><li>关于编译器自动生成的析构函数，是否会完成一些事情呢？下面的程序我们会看到，编译器生成的 默认析构函数，对会自定类型成员调用它的析构函数。</li></ol><h4 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h4><p>构造函数：只有单个形参，该形参是对本类类型对象的引用(一般常用const修饰)，在用已存在的类类型对象创建新对象时由<strong>编译器自动调用</strong>。</p><h5 id="拷贝构造函数特征"><a href="#拷贝构造函数特征" class="headerlink" title="拷贝构造函数特征:"></a>拷贝构造函数特征:</h5><ol><li><p>拷贝构造函数是构造函数的一个重载形式。 </p></li><li><p>拷贝构造函数的参数只有一个且必须使用引用传参，使用传值方式会引发无穷递归调用。</p><p>这是因为传参数的时候形参是实参的一份拷贝,而形参并没有初始化,所以要调用拷贝构造</p><p>而调用拷贝构造函数时又创建了另一个形参又要拷贝构造所以会无穷递归,传引用就没有</p><p>调用拷贝构造</p></li></ol><p>   <img src="C:\Users\VSAS\AppData\Roaming\Typora\typora-user-images\1559629437160.png" alt="1559629437160"></p><ol start="3"><li>若未显示定义，系统生成默认的拷贝构造函数。 默认的拷贝构造函数对象按内存存储按字节序完成拷 贝，这种拷贝我们叫做浅拷贝，或者值拷贝。</li></ol><p><strong>下面这几种情况下会调用拷贝构造函数</strong></p><p>（1）显式或隐式地用同类型的一个对象来初始化另外一个对象。如上例中的CExample ccc = aaa;</p><p>（2）作为实参传递给一个函数。如上例中的bbb.myTestFunc(aaa);</p><p>（3）在函数体内返回一个对象时，也会调用返回值类型的拷贝构造函数</p><p>（4）初始化序列容器中的元素时。比如vector<string> svec(5)，string的缺省构造函数和拷贝构造函数都会被调用。</string></p><p>（5）用列表的方式初始化数组元素时。string a[] = {string(“hello”),string(“world”)};会调用string的拷贝构造函数。</p><h4 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h4><h5 id="运算符的重载"><a href="#运算符的重载" class="headerlink" title="运算符的重载"></a>运算符的重载</h5><p> C++为了增强代码的可读性引入了运算符重载，运算符重载是具有特殊函数名的函数，也具有其返回值类 型，函数名字以及参数列表，其返回值类型与参数列表与普通的函数类似。<br><strong>函数原型：返回值类型 operator操作符(参数列表)</strong><br>注意：<br><strong>不能通过连接其他符号来创建新的操作符</strong>：比如operator@ 重载操作符必须有一个类类型或者枚举类型的操作数 用于内置类型的操作符，其含义不能改变，例如：内置的整型+，不 能改变其含义<br>作为类成员的重载函数时，其形参看起来比操作数数目少1成员函数的 操作符有一个默认的形参this，限定为第一个形参 </p><p><strong>.* 、:: 、sizeof  、?:   、.  注意以上5个运算符不能重载。</strong></p><h5 id="赋值运算符重载-1"><a href="#赋值运算符重载-1" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h5><ol><li>参数类型 </li><li>返回值 </li><li>检测是否自己给自己赋值 </li><li>返回*this </li><li>一个类如果没有显式定义赋值运算符重载，编译器也会生成一个，完成对象按字节序的值拷贝。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信号量</title>
      <link href="/2019/08/15/%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
      <url>/2019/08/15/%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>信号是进程之间时间异步通知的方式，属于软中断，信号是一个标记每个信号表示一种事件，位图注册信号表示进程发生了这个事件，sigqueue节点添加一个表示这个事件发生了一次。</p><p>信号阻塞是阻止信号被递达（暂时不处理信号）在进程pcb中标记 那些信号来了不处理 在进程pcb中有个信号阻塞集，阻塞信号就是在这个集合做标记，当信号需要被处理时进行（pending&amp;~block）操作来判定这个信号需要阻塞还是递达。</p><a id="more"></a><h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>信号的基本认知</strong>:软件的中断,通知时间的发生，（进程之间时间异步通知的方式，属于软中断）</p><p><strong>生命周期</strong>：信号的生命周期:产生–&gt;注册–&gt;注销–&gt;处理/阻塞</p><h2 id="信号的种类"><a href="#信号的种类" class="headerlink" title="信号的种类"></a>信号的种类</h2><p><strong>查看方式：kill  -l</strong>，查看Linux下系统定义的信号列表，每个信号都有一个编号和一个宏定义名称,这些宏定义可以在signal.h中找到,这些信号各自在什么条件下 产生,默认的处理动作是什么,在signal(7)中都有详细明:<strong>man7signal</strong></p><p><img src="D:\MyBlog\source\images\signal.png" alt=""></p><p><strong>Linux下系统定义的信号列表</strong>：62种</p><p> <strong>1-31</strong>对应不同的事件     非可靠信号/非实时(事件可能会丢失/是否立即会处理)</p><p> <strong>34-64</strong>用户添加的信号    可靠信号/实时信号</p><p>信号的生命周期:产生–&gt;注册–&gt;注销–&gt;处理     阻塞</p><h2 id="信号的产生"><a href="#信号的产生" class="headerlink" title="信号的产生"></a>信号的产生</h2><h3 id="1-硬件产生"><a href="#1-硬件产生" class="headerlink" title="1.硬件产生:"></a>1.硬件产生:</h3><p>如键盘操作：Ctrl+c Ctrl+l Ctrl+z </p><h4 id="core-dump-解析"><a href="#core-dump-解析" class="headerlink" title="core dump 解析"></a>core dump 解析</h4><p><strong>core dumped :黑匣子,默认关闭,占磁盘资源</strong>当一个进程要异常终止时,可以选择把进程的用户空间内存数据全部 保存到磁 盘上,文件名通常是core,这叫做Core Dump。进程异常终止通常是因为有Bug,比如非法内存访问导致段错误, 事后可以用调试器检查core文件以查清错误原因,这叫做Post-mortem Debug（事后调试）。一个进程允许 产生多大的core文件取决于进程的Resource Limit(这个信息保存 在PCB中)。默认是不允许产生core文件的, 因为core文件中可能包含用户密码等敏感信息,不安全。在开发调试阶段可以用ulimit命令改变这个限制,允许 产生core文件。</p><p> 首先用ulimit命令改变Shell进程的Resource Limit,允许core文件最大为1024K: $ ulimit -c 1024</p><p>进程异常运行时，保存信息到core.pid文件中方便调试</p><p>ulimit -a 查看是否开启0</p><p>ulimit -c  1024 设置大小,开启核心转储文件</p><p>gdb./loop  –&gt; c ore-file core.pid –&gt;bt</p><h3 id="3-软件产生"><a href="#3-软件产生" class="headerlink" title="3.软件产生"></a>3.软件产生</h3><p>kill命令是调用kill（）函数实现的。kill函数可以给一个指定的进程发送指定的信号。</p><p>raise函数可以给当前进程发送指定 的信号(自己给自己发信号)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> signo)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">kill函数可以给一个指定的进程发送指定的信号。</span><br><span class="line">参数：</span><br><span class="line">   给指定进程发送指定信号</span><br><span class="line">   sig 信号种类</span><br><span class="line">返回值：</span><br><span class="line">成功返回<span class="number">0</span>,错误返回<span class="number">-1</span>。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> signo)</span></span>;</span><br><span class="line">参数：</span><br><span class="line">raise函数可以给当前进程发送指定的信号</span><br><span class="line">参数：</span><br><span class="line">sig 信号种类</span><br><span class="line">返回值：</span><br><span class="line">这两个函数都是成功返回<span class="number">0</span>,错误返回<span class="number">-1</span>。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abort</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">给调用进程发送SIGABRT信号</span><br><span class="line">就像<span class="built_in">exit</span>函数一样,<span class="built_in">abort</span>函数总是会成功的,所以没有返回值。</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>;</span><br><span class="line">给调用进程指定时间后发送SIGALRM信号</span><br><span class="line">返回上一个定时器剩余的时间或<span class="number">0</span></span><br><span class="line">参数为<span class="number">0</span>表示取消定时器返回上一个定时器的剩余时间</span><br></pre></td></tr></table></figure><h2 id="信号注册"><a href="#信号注册" class="headerlink" title="信号注册"></a>信号注册</h2><h3 id="信号的相关概念"><a href="#信号的相关概念" class="headerlink" title="信号的相关概念"></a>信号的相关概念</h3><ul><li>实际执行信号的处理动作称为<strong>信号递达</strong>(Delivery) </li><li>信号从产生到递达之间的状态,称为<strong>信号未决</strong>(Pending)。 </li><li>进程可以选择阻塞 (Block )某个信号。 </li><li>被阻塞的信号产生时将保持在未决状态,直到进程解除对此信号的阻塞,才执行递达的动作. </li><li>注意,阻塞和忽略是不同的,只要信号被阻塞就不会递达,而忽略是在递达之后可选的一种处理动作。  </li></ul><h3 id="在内核中的表示"><a href="#在内核中的表示" class="headerlink" title="在内核中的表示"></a>在内核中的表示</h3><p><img src="D:\MyBlog\source\images\sigpending.png" alt=""></p><p>在pcb中做标记：<strong>修改未决信号集合（</strong>位图）中对应的信号位。每个<strong>信号都有两个标志位分别表示阻塞(block)和未决(pending)</strong>,还有一个<strong>函数指针表示处理动作</strong>。信号产生时,内核在进程控制块（pcb）中设置该信号的未决标志,直到信号递达才清除该标志。在上图的例子 中,SIGHUP信号未阻塞也未产生过,当它递达时执行默认处理动作。 SIGINT信号产生过,但正在被阻塞,所以暂时不能递达。虽然它的处理动作是忽略,但在没有解除阻塞之前不能忽略这个信号,因为进程仍有机会改变处理动作之后再解除阻塞。 SIGQUIT信号未产生过,一旦产生SIGQUIT信号将被阻塞,它的处理动作是用户自定义函数sighandler（）。 </p><p>如果在进程解除对某信号的阻塞之前这种信号产生过多次,将如何处理?POSIX.1允许系统递送该信号一次 或多次。Linux是这样实现的:常规信号在递达之前产生多次只计一次,而实时信号在递达之前产生多次可 以依次放在一个队列里（sigqueue）</p><h4 id="sigset"><a href="#sigset" class="headerlink" title="sigset"></a>sigset</h4><p>每个信号只有一个bit的未决标志,非0即1,不记录该信号产生了多少次,阻塞标志也是这样表示的。 因此,未决和阻塞标志可以用相同的数据类型sigset_t来存储,sigset_t称为信号集,这个类型可以表示每个信号 的“有效”或“无效”状态,在阻塞信号集中“有效”和“无效”的含义是该信号是否被阻塞,而在未决信号集中“有 效”和“无效”的含义是该信号是否处于未决状态。下一节将详细介绍信号集的各种操作。 阻塞信号集也叫做当 前进程的信号屏蔽字(Signal Mask),这里的“屏蔽”应该理解为阻塞而不是忽略。 </p><h3 id="信号的注册"><a href="#信号的注册" class="headerlink" title="信号的注册"></a>信号的注册</h3><p><strong>非可靠信号的注册</strong>：判断是否有相同的未决信号，若有，则什么也不做；否则修改位图添加结点</p><p><strong>可靠信号的注册</strong>：是否有相同未决信号的注册，若没有修改位图添加节点；否则直接添加结点</p><h2 id="信号的注销"><a href="#信号的注销" class="headerlink" title="信号的注销"></a>信号的注销</h2><p>非可靠信号注销：删除信号的sigqueue结点，修改位图（非可靠信号只会注册一次）</p><p>可靠信号注册：删除节点，检测是否还有相同信号，若有则位图依然置1否则修改为0</p><h2 id="信号的处理："><a href="#信号的处理：" class="headerlink" title="信号的处理："></a>信号的处理：</h2><h4 id="默认处理方式："><a href="#默认处理方式：" class="headerlink" title="默认处理方式："></a>默认处理方式：</h4><p>操作系统(内核)既定的处理方式—-SIG_DFL，可能是以下的某种类型：</p><p>Treminate：进程被终止(杀死)</p><p>Dump：进程被终止(杀死)，如果可能，创建包含进程执行上下文的核心转储文件(core dump)</p><p>Ignore：信号被忽略</p><p>Stop：进程被停止，即把进程置为TASK_STOPPED状态</p><h4 id="忽略处理方式"><a href="#忽略处理方式" class="headerlink" title="忽略处理方式"></a>忽略处理方式</h4><p>这与默认中的忽略是不同的，该处理方式处理了信号，但是什么都没有做</p><h4 id="​-自定义处理方式"><a href="#​-自定义处理方式" class="headerlink" title="​ 自定义处理方式"></a>​ 自定义处理方式</h4><p>提供一个信号处理函数,要求内核在处理该信号时切换到用户态执行这个处理函数,这种方式称为捕捉Catch)一个信号。<strong>有两个信号无法被阻塞,忽略,自定义SIGKILL,SIGSTOP19</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">sighandler_t</span> signal(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler);</span><br><span class="line">参数：</span><br><span class="line">signum信号编号</span><br><span class="line">handler 函数指针使用函数指针替换signum的处理方式</span><br><span class="line"></span><br><span class="line">SIG_DFL ：默认</span><br><span class="line">SIG_IGN ：忽略</span><br></pre></td></tr></table></figure><h4 id="自定信号处理方式的处理流程："><a href="#自定信号处理方式的处理流程：" class="headerlink" title="自定信号处理方式的处理流程："></a>自定信号处理方式的处理流程：</h4><p>用户态切换到内核态，完毕后准备从内核态切换回用户态的时候去处理信号若信号为默认或者忽略处理，则在内核中直接完成，但是信号如果是自定义的处理方式，则需要返回用户态执行信号回调函数，执行完毕后回到内核态没有信号则回到信号主流程</p><p><img src="D:\MyBlog\source\images\信号捕捉.png" alt=""></p><h4 id="自定义信号捕捉"><a href="#自定义信号捕捉" class="headerlink" title="自定义信号捕捉"></a>自定义信号捕捉</h4><p>如果信号的处理动作是用户自定义函数,在信号递达时就调用这个函数,这称为捕捉信号。由于信号处理函数的代码 是在用户空间的,处理过程比较复杂,举例如下: 用户程序注册了SIGQUIT信号的处理函数sighandler。 当前正在执行 main函数,这时发生中断或异常切换到内核态。 在中断处理完毕后要返回用户态的main函数之前检查到有信号 SIGQUIT递达。 内核决定返回用户态后不是恢复main函数的上下文继续执行,而是执行sighandler函数,sighandler 和main函数使用不同的堆栈空间,它们之间不存在调用和被调用的关系,是 两个独立的控制流程。 sighandler函数返 回后自动执行特殊的系统调用sigreturn再次进入内核态。 如果没有新的信号要递达,这次再返回用户态就是恢复 main函数的上下文继续执行了。 </p><h5 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction"></a>sigaction</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signo, <span class="keyword">const</span> struct sigaction *act, struct sigaction *oact)</span></span>; </span><br><span class="line">参数：</span><br><span class="line">sigaction函数可以读取和修改与指定信号相关联的处理动作。调用成功则返回<span class="number">0</span>,出错则返回- <span class="number">1</span>。signo</span><br><span class="line">是指定信号的编号。若act指针非空,则根据act修改该信号的处理动作。若oact指针非 空,则通过oact传</span><br><span class="line">出该信号原来的处理动作。act和oact指向sigaction结构体:</span><br><span class="line">将sa_handler赋值为常数SIG_IGN传给sigaction表示忽略信号,赋值为常数SIG_DFL表示执行系统默认动</span><br><span class="line">作,赋值为一个函数指针表示用自定义函数捕捉信号,或者说向内核注册了一个信号处理函 数,该函数返回</span><br><span class="line">值为<span class="keyword">void</span>,可以带一个<span class="keyword">int</span>参数,通过参数可以得知当前信号的编号,这样就可以用同一个函数处理多种信</span><br><span class="line">号。显然,这也是一个回调函数,不是被main函数调用,而是被系统所调用。</span><br><span class="line">当某个信号的处理函数被调用时,内核自动将当前信号加入进程的信号屏蔽字,当信号处理函数返回时自动恢复原来</span><br><span class="line">的信号屏蔽字,这样就保证了在处理某个信号时,如果这种信号再次产生,那么 它会被阻塞到当前处理结束为止。 如果</span><br><span class="line">在调用信号处理函数时,除了当前信号被自动屏蔽之外,还希望自动屏蔽另外一些信号,则用sa_mask字段说明这些需</span><br><span class="line">要额外屏蔽的信号,当信号处理函数返回时自动恢复原来的信号屏蔽字。 sa_flags字段包含一些选项,本章的代码都</span><br><span class="line">把sa_flags设为<span class="number">0</span>,sa_sigaction是实时信号的处理函数</span><br></pre></td></tr></table></figure><h4 id="函数的可重入与不可重入"><a href="#函数的可重入与不可重入" class="headerlink" title="函数的可重入与不可重入"></a>函数的可重入与不可重入</h4><p>一个函数是否可以在多个运行时序中重复调用而不会出现任何问题，在一个函数中是否进行了对全局数据的非原子性操作。</p><p><strong>可重入函数：</strong>在多个时序的运行中重复调用，不会造成异常影响。比如在某个函数的调用中，还没有返回时就再次进入该函数，就称为重入。</p><p><strong>不可重入函数：</strong>不能再多个时序中重复调用，比如malloc和free函数。如果随意的调用则会发生内存泄漏。</p><p>时序的竞争执行：函数的可重入与不可重入（是否进行了）对全局数据的非原子性操作</p><p>关键字：volatile：保持内存可见性—防止编译器过度优化-每次对变量访问都从内存重新获取</p><h4 id="SIGCHLD"><a href="#SIGCHLD" class="headerlink" title="SIGCHLD"></a>SIGCHLD</h4><p>SIGCHLD：子进程退出，操作系统通知父进程，自定义一个SIGCGLD信号处理方式sigcb，当子进程退出操作系统发送信号给父进程直接触发信号回调sigbc用户主要在sigbc中调用wait/wait_pid就可以处理子进程退出sigchld是一个非可靠信号，假如有多个子进程同时退出则有可能造成事件丢失导致sigbc只被调用一次，只处理了一个子进程因此需要在sigcb中需要用户循环非阻塞处理子进程退出，直到没有子进程退出while（waitpid（-11，NULL，WONOHANG）&gt; 0)//因为&gt;0表示有子进程退出必须用非阻塞，否则没有子进程·退出的时候waitpid将阻塞导致进程无法回到主控流程  </p><h3 id="信号集操作函数"><a href="#信号集操作函数" class="headerlink" title="信号集操作函数"></a>信号集操作函数</h3><h4 id="初始化函数"><a href="#初始化函数" class="headerlink" title="初始化函数"></a>初始化函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">函数sigemptyset初始化<span class="built_in">set</span>所指向的信号集,使其中所有信号的对应bit清零,表示该信号集不包含 任何有效信号。</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">函数sigfillset初始化<span class="built_in">set</span>所指向的信号集,使其中所有信号的对应bit置位,表示 该信号集的有效信号包括系统支持的所有信号</span><br><span class="line">注意：</span><br><span class="line">在使用sigset_ t类型的变量之前,一定要调 用sigemptyset或sigfillset做初始化,使信号集处于确定的</span><br><span class="line">状态。</span><br><span class="line">返回值：</span><br><span class="line">函数都是成功返回<span class="number">0</span>,出错返回<span class="number">-1</span>。</span><br></pre></td></tr></table></figure><h4 id="操作函数"><a href="#操作函数" class="headerlink" title="操作函数"></a>操作函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">初始化<span class="keyword">sigset_t</span>变量之后就可以在调用sigaddset和sigdelset在该信号集中添加或删除某种有效信号。</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span> <span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signo)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signo)</span></span>;</span><br><span class="line">函数都是成功返回<span class="number">0</span>,出错返回<span class="number">-1</span>。</span><br><span class="line"><span class="keyword">int</span> sigismember（<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signo);</span><br><span class="line">sigismember是一个布尔函数,用于判断一个信号集的有效信号中是否包含某种 信号,若包含则返回<span class="number">1</span>,不包含则返回<span class="number">0</span>,出错返回<span class="number">-1</span>。</span><br></pre></td></tr></table></figure><h4 id="阻塞信号信号集"><a href="#阻塞信号信号集" class="headerlink" title="阻塞信号信号集"></a>阻塞信号信号集</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">sigset_t</span> *oset)</span></span>; </span><br><span class="line">返回值:若成功则为<span class="number">0</span>,若出错则为<span class="number">-1</span></span><br><span class="line">参数：</span><br><span class="line">如果oset是非空指针,则读取进程的当前信号屏蔽字通过oset参数传出。<span class="number">4</span>如果<span class="built_in">set</span>是非空指针,则 更改进程的信</span><br><span class="line">号屏蔽字,参数how指示如何更改。如果oset和<span class="built_in">set</span>都是非空指针,则先将原来的信号 屏蔽字备份到oset里,然后</span><br><span class="line">根据<span class="built_in">set</span>和how参数更改信号屏蔽字</span><br><span class="line">参数how：</span><br><span class="line">trueSIG_BLOCK:<span class="built_in">set</span>包含了我们希望添加到当前信号屏蔽字的信号相当于mask=mask|<span class="built_in">set</span></span><br><span class="line">trueSIG_UNBLOCK:<span class="built_in">set</span>包含了我们希望从当前信号屏蔽字中解除的阻塞信号相当于mask=mask|~<span class="built_in">set</span></span><br><span class="line">trueSIG_SETMASK:设置当前屏蔽字信号为<span class="built_in">set</span>所指向的值相当于mask = <span class="built_in">set</span></span><br><span class="line">注意：</span><br><span class="line">true如果调用sigprocmask解除了对当前若干个未决信号的阻塞,则在sigprocmask返回前,至少将其中一个信号递</span><br><span class="line">达。</span><br></pre></td></tr></table></figure><h4 id="sigpending"><a href="#sigpending" class="headerlink" title="sigpending"></a>sigpending</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpending</span><span class="params">(<span class="keyword">sigset_t</span>* <span class="built_in">set</span>)</span></span></span><br><span class="line">读取当前进程的未决信号集,通过set参数传出。调用成功则返回0,出错则返回-1。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Http应用层协议</title>
      <link href="/2019/06/16/Http%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE/"/>
      <url>/2019/06/16/Http%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="应用层和HTTP协议"><a href="#应用层和HTTP协议" class="headerlink" title="应用层和HTTP协议"></a>应用层和HTTP协议</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p><strong>序列化</strong>:将数据持久化存储或网络数据传输格式进行排布</p><p><strong>反序列化</strong>:对数据一指定协议进行解析</p><p><strong>序列化的几种方式</strong>：</p><p><strong>协议</strong>：一种约定分类有知名协议和自定制协议</p><a id="more"></a> <h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><h5 id="网络通过应用层为用户提供多种服务，应用层的具体内容就是规定应用进程在通信时所遵循的协议。有以下功能："><a href="#网络通过应用层为用户提供多种服务，应用层的具体内容就是规定应用进程在通信时所遵循的协议。有以下功能：" class="headerlink" title="网络通过应用层为用户提供多种服务，应用层的具体内容就是规定应用进程在通信时所遵循的协议。有以下功能："></a>网络通过应用层为用户提供多种服务，应用层的具体内容就是规定应用进程在通信时所遵循的协议。有以下功能：</h5><ul><li>确立通信双方的有效性     </li><li>同步相互通信的应用程序</li><li>建立错误恢复的机制</li><li>控制数据的一致性</li></ul><h5 id="应用层协议定义："><a href="#应用层协议定义：" class="headerlink" title="应用层协议定义："></a>应用层协议定义：</h5><ul><li>应用进程交换的报文类型，请求还是协议</li><li>各种报文类型的语法，如报文中的各个字段和他详细的描述。</li><li>字段的语义，包含在字段中信息的含义。</li><li>进程何时发送报文，如何发送报文，以及对报文的相应规则。</li></ul><h5 id="网络应用模型："><a href="#网络应用模型：" class="headerlink" title="网络应用模型："></a>网络应用模型：</h5><h6 id="C-S模型：客户端-服务器"><a href="#C-S模型：客户端-服务器" class="headerlink" title="C/S模型：客户端/服务器"></a>C/S模型：客户端/服务器</h6><p>服务器:1.永久提供服务。2.永久性访问地址/域名</p><p>客户端：1.</p><p>P2P:</p><h5 id="应用层常见协议："><a href="#应用层常见协议：" class="headerlink" title="应用层常见协议："></a>应用层常见协议：</h5><p>简单电子邮件传输（SMTP）：</p><p>文件传输协议（FTP）：</p><p>网络远程访问协议（Telnet）：</p><p>超文本传输协议(HTTP)：</p><p>可扩展通讯和表示协议（XMPP）：</p><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h3 id="URL-统一资源定位符"><a href="#URL-统一资源定位符" class="headerlink" title="URL:统一资源定位符"></a>URL:统一资源定位符</h3><p>协议名称://用户名:密码@服务器地址:服务器端口/资源路径?查询字符串#片段标识符</p><p><img src="D:\MyBlog\source\images\url格式图.png" alt=""></p><h3 id="URL编码-解码"><a href="#URL编码-解码" class="headerlink" title="URL编码/解码"></a>URL编码/解码</h3><p>查询字符串:urlencode/urldecode,因为HTTP中参数出以&lt;key,val&gt;组成键值对,以&amp;连接</p><p>像 / ? : 等这样的字符, 已经被url当做特殊意义理解了. 因此这些字符不能随意出现. 比如, 某个参数中需要带有这些特殊字符, 就必须先对特殊字符进行转义.<br>转义的规则如下:  将需要转码的字符转为16进制，然后从右到左，取4位(不足4位直接处理)，每2位做一位，前面加上%，编码成%XY 格式</p><p>课后调研实现urlencode/urldecode</p><h3 id="HTPP协议格式"><a href="#HTPP协议格式" class="headerlink" title="HTPP协议格式"></a>HTPP协议格式</h3><h4 id="HTTP的三大部分-首行-头部-正文"><a href="#HTTP的三大部分-首行-头部-正文" class="headerlink" title="HTTP的三大部分:首行,头部,正文"></a>HTTP的三大部分:首行,头部,正文</h4><h5 id="请求消息格式"><a href="#请求消息格式" class="headerlink" title="请求消息格式"></a>请求消息格式</h5><p><img src="D:\MyBlog\source\images\http协议格式.webp" alt=""></p><h5 id="首行-请求首行-相应首行"><a href="#首行-请求首行-相应首行" class="headerlink" title="首行:请求首行,相应首行"></a>首行:请求首行,相应首行</h5><h5 id="请求首行-请求方法-GET-POST-HEAD-PUT-DELETE-HTTP协议版本-0-9-1-0-1-1-2"><a href="#请求首行-请求方法-GET-POST-HEAD-PUT-DELETE-HTTP协议版本-0-9-1-0-1-1-2" class="headerlink" title="请求首行:请求方法(GET/POST/HEAD/PUT/DELETE) HTTP协议版本(0.9/1.0/1.1/2)"></a>请求首行:请求方法(GET/POST/HEAD/PUT/DELETE) HTTP协议版本(0.9/1.0/1.1/2)</h5><h5 id="头部-一-请求的属性-冒号分割的键值对-每组属性之间使用-n分隔-遇到空行表示Header部分结束"><a href="#头部-一-请求的属性-冒号分割的键值对-每组属性之间使用-n分隔-遇到空行表示Header部分结束" class="headerlink" title="头部:一 请求的属性, 冒号分割的键值对;每组属性之间使用\n分隔;遇到空行表示Header部分结束"></a>头部:一 请求的属性, 冒号分割的键值对;每组属性之间使用\n分隔;遇到空行表示Header部分结束</h5><p>key: val\r\n key: val\r\n</p><p><strong>常见的请求方法 </strong></p><ul><li><p>GET方法:请求指定的页面信息，并返回实体主体</p></li><li><p>POST方法:向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。</p></li><li><p>PUT:从客户端向服务器传送的数据取代指定的文档的内容</p></li></ul><h4 id="GET-POST区别-get无正文-post有正文"><a href="#GET-POST区别-get无正文-post有正文" class="headerlink" title="GET/POST区别:get无正文 post有正文"></a><strong>GET/POST区别:get无正文 post有正文</strong></h4><p>1.请求参数的区别</p><p><code>GET</code>请求会把请求的参数拼接在<code>URL</code>后面，以<code>?</code>分隔，多个参数之间用<code>&amp;</code>连接；如果是英文或数字，原样发送，如果是空格或中文，则用<a href="https://link.jianshu.com?t=https://segmentfault.com/a/1190000004533485?_ea=657625" target="_blank" rel="noopener">Base64</a>编码</p><p><code>POST</code>请求会把提交的数据放在请求体中，不会在<code>URL</code>中显示出来</p><p>2.传输数据的大小</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET`: 浏览器和服务器会限制`URL`的长度，所以传输的数据有限，一般是<span class="number">2</span>K</span><br></pre></td></tr></table></figure><p><code>POST</code>: 由于数据不是通过<code>URL</code>传递，所以一般可以传输较大量的数据</p><p>3.数据解析</p><p><code>GET</code>: 通过<code>Request.QueryString</code>获取变量的值</p><p><code>POST</code>: 通过<code>Request.form</code>获取变量的值</p><p>4.安全性</p><p><code>GET</code>: 请求参数在<code>URL</code>后面，可以直接看到，尤其是登录时，如果登录界面被浏览器缓存，其他人就可以通过查看历史记录，拿到账户和密码</p><p><code>POST</code>: 请求参数在请求体里面传输，无法直接拿到，相对<code>GET</code>安全性较高；但是通过抓包工具，还是可以看到请求参数的</p><h4 id="HTTP-0-9-1-0-1-1-2-0区别"><a href="#HTTP-0-9-1-0-1-1-2-0区别" class="headerlink" title="HTTP 0.9/1.0/1.1/2.0区别"></a>HTTP 0.9/1.0/1.1/2.0区别</h4><p><strong>HTTP 0.9 ：</strong></p><ul><li>只接受GET一种请求方法，没有在通信中指定版本号，且不支持请求头；</li><li>此外该版本也不支持POST方法，因此客户端无法向服务器传递太多信息；</li><li>短连接</li></ul><p><strong>HTTP 1.0：</strong></p><ul><li>支持POST、GET、HEAD三种方法；</li><li>规定浏览器与服务器之间只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求；</li></ul><p><strong>HTTP 1.1：</strong></p><ul><li><p>新增了五种请求方法：PUT、DELETE、CONNECT、TRACE、OPTIONS；</p></li><li><p>HTTP 1.1 在Request消息头里头多了一个Host域，便于一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点；</p></li><li>在HTTP/1.1中新增了24个状态响应码：<br>100-199 用于指定客户端应相应的某些动作。<br>200-299 用于表示请求成功。<br>300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。<br>400-499 用于指出客户端的错误。<br>500-599 用于支持服务器错误。</li></ul><p><strong>HTTP2.0：</strong></p><ul><li><p>HTTP2.0使用多路复用技术(Multiplexing),多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。”HTTP1.1在同一时间对于同一个域名的请求数量有限制，超过限制就会阻塞请求”。多路复用底层采用”增加二进制分帧层”的方法，使得不改变原来的语义、首部字段的情况下提高传输性能，降低延迟。二进制分帧将所有传输信息分割为更小的帧，用二进制进行编码，多个请求都在同一个TCP连接上完成，可以承载任意数量的双向数据流。HTTP/2更有效的使用TCP连接，得到性能上的提升</p><p><strong>详解：</strong></p><p>[<a href="https://www.jianshu.com/p/ac628fda40f2?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation]" target="_blank" rel="noopener">https://www.jianshu.com/p/ac628fda40f2?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation]</a>: </p></li></ul><h5 id="正文"><a href="#正文" class="headerlink" title="正文:"></a>正文:</h5><p>空行后面的内容都是Body. Body允许为空字符串. 如果Body存在, 则在Header中会有一个 </p><p>Content-Length属性来标识Body的长度;</p><h5 id="响应消息格式"><a href="#响应消息格式" class="headerlink" title="响应消息格式"></a>响应消息格式</h5><p>响应首行: [版本号] + [状态码] + [状态码解释] </p><p>Header: 请求的属性, 冒号分割的键值对;每组属性之间使用\n分隔;遇到空行表示Header部分结束 </p><p>Body: 空行后面的内容都是Body. Body允许为空字符串. 如果Body存在, 则在Header中会有一个 </p><p>Content-Length属性来标识Body的长度; 如果服务器返回了一个html页面, 那么html页面内容就是在 </p><p>body中.  </p><h5 id="常见响应头"><a href="#常见响应头" class="headerlink" title="常见响应头"></a>常见响应头</h5><p>Content-Type: 数据类型(text/html等) </p><p>Content-Length: Body的长度 </p><p>Host: 客户端告知服务器, 所请求的资源是在哪个主机的哪个端口上; </p><p>User-Agent: 声明用户的操作系统和浏览器版本信息; </p><p>referer: 当前页面是从哪个页面跳转过来的; </p><p>location: 搭配3xx状态码使用, 告诉客户端接下来要去哪里访问; </p><p>Cookie: 用于在客户端存储少量信息. 通常用于实现会话(session)的功能;  </p><h5 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h5><p>HTTP协议的状态码由3位数字组成，第一个数字定义了响应的类别，共有5中类别：</p><ul><li>1xx: 指示信息–表示请求已接收，继续处理</li><li>2xx: 成功–表示请求已被成功接收、理解、接受</li><li>3xx: 重定向–要完成请求必须进行更进一步的操作</li><li>4xx: 客户端错误–请求有语法错误或请求无法实现</li><li>5xx: 服务器端错误–服务器未能实现合法的请求</li></ul><p>常见状态码:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">200 </span>OK                        //客户端请求成功</span><br><span class="line"><span class="symbol">400 </span>Bad Request               //客户端请求有语法错误，不能被服务器所理解</span><br><span class="line"><span class="symbol">401 </span>Unauthorized              //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 </span><br><span class="line"><span class="symbol">403 </span>Forbidden                 //服务器收到请求，但是拒绝提供服务</span><br><span class="line"><span class="symbol">404 </span><span class="keyword">Not</span> Found                 //请求资源不存在，eg：输入了错误的URL</span><br><span class="line"><span class="symbol">500 </span>Internal Server <span class="keyword">Error</span>     //服务器发生不可预期的错误</span><br><span class="line"><span class="symbol">503 </span>Server Unavailable        //服务器当前不能处理客户端的请求，一段时间后可能恢复正常</span><br></pre></td></tr></table></figure><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><code>HTTP</code>协议采用请求/响应模式，客户端向服务器发送一个请求报文，然后服务器响应请求。下面介绍一下一次<code>HTTP</code>请求的过程：</p><ol><li>在浏览器中输入<code>URL</code>，并按下回车键</li><li>浏览器向<code>DNS</code>服务器请求解析该<code>URL</code>中的域名对应的<code>IP</code>地址(如果是<code>IP</code>请求，则不需要该步骤)</li><li>解析出<code>IP</code>后，根据<code>IP</code>和端口号，和服务器建立<a href="https://www.jianshu.com/p/ef892323e68f" target="_blank" rel="noopener">TCP</a>连接</li><li>浏览器向服务器发送请求，该请求报文作为<code>TCP</code>三次握手的第三个报文发送给服务器</li><li>服务器做出响应，把数据发送给浏览器</li><li>通信完成，断开<code>TCP</code>连接</li><li>浏览器解析收到的数据并显示</li></ol><h3 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h3><p><code>HTTPS</code>是安全的<code>HTTP</code>通道，即在HTTP通信中加入了<code>SSL</code>层（当前版本是<code>TLS1.2</code>），通信的数据被加密了，防止被窃取，具体的通信流程如下：</p><p><img src="D:\MyBlog\source\images\HTTPS.png" alt=""></p><p>HTTPS使用的加密方式结合了对称加密和不对称加密的特点，在保证安全的情况下，又提高了传输效率。HTTP和HTTPS的区别如下：</p><p>1.https协议需要到ca申请证书，一般免费证书很少，需要交费。</p><p>2.http的信息是明文传输，https 则是具有安全性的ssl加密传输协议。</p><p>3.http和https用的端口不一样，前者是80，后者是443。</p><p>4.http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作符总结</title>
      <link href="/2019/01/22/%E6%93%8D%E4%BD%9C%E7%AC%A6%E6%80%BB%E7%BB%93/"/>
      <url>/2019/01/22/%E6%93%8D%E4%BD%9C%E7%AC%A6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>同一优先级的运算符，结合次序由结合方向所决定。<br>简单记就是：！ &gt; 算术运算符 &gt; 关系运算符 &gt; &amp;&amp; &gt; || &gt; 赋值运算符<br><a id="more"></a></p><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p><strong>1.算数操作符:+,-,/,*,%</strong><br>这部分只需注意/,%的除数不可以为零,模运算只能是整型<br><strong>2.移位操作符:&lt;&lt;,&gt;&gt;</strong><br>移位的规则:左移操作:左边抛弃右边补零<br>                   右移操作:逻辑右移:左边用0填充,右边丢弃<br>                                  算数右移:左边用符号位填充,右边丢弃<br> 这里还需要注意位移操作符的对象是整型,进行操作时要考虑是否越界,移位的值必须非负,                               <img src="https://img-blog.csdnimg.cn/20190122155923779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4ODMzMjU3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>标准说明无符号值进行所有移位操作都是逻辑移位,有符号值取决于编译器</p></blockquote><p>所以不建议使用移位操作这样程序的可移植性差<br><strong>位操作:&amp;,|,^</strong><br>操作数必须为整数<br>下面是常见的的使用场景:<br>1)给指定位赋1或0<br>2)一个数中1的个数<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> GetoneCount(<span class="built_in">int</span> <span class="keyword">number</span>) &#123;</span><br><span class="line">true<span class="built_in">int</span> <span class="built_in">count</span> = <span class="number">0</span>;</span><br><span class="line">truefor (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">32</span>; ++i) &#123;</span><br><span class="line">truetrue<span class="keyword">if</span> (<span class="keyword">number</span>&amp;(<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">truetruetrue<span class="built_in">count</span>++;</span><br><span class="line">true&#125;</span><br><span class="line">true<span class="keyword">return</span> <span class="built_in">count</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>求补和逗号操作符</strong><br>1.逗号表达式的值为从左到右最后一个<br> <strong>关系操作符</strong><br> 1.其结果值得类型为整型<br> 2.=,==是不同的<br> 在C语言中=为赋值 ==为比较<br> <strong>逻辑操作符</strong><br> 1.短路求值先左再右<br> 2.&amp;,&amp;&amp;,|,||的区别<br> 逻辑操作用于测试0值和非0值而位操作用于比较操作数中对应的位<br><strong>左值和右值</strong><br>左值标识了一个储存结果值的地点,标识了一个特定的位置,字面值常量也都不是左值<br>这个地址指的是程序员可以获得的<br><strong>操作符的优先级和求值顺序</strong><br> 同一优先级的运算符，结合次序由结合方向所决定。<br>简单记就是：！ &gt; 算术运算符 &gt; 关系运算符 &gt; &amp;&amp; &gt; || &gt; 赋值运算符</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言总结 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
