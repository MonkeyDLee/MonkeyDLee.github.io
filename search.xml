<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++类和对象</title>
      <link href="/2019/08/15/C-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
      <url>/2019/08/15/C-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>信号量</title>
      <link href="/2019/08/15/%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
      <url>/2019/08/15/%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>信号的基本认知</strong>:软件的中断,通知时间的发生，（进程之间时间异步通知的方式，属于软中断）</p><p><strong>生命周期</strong>：信号的生命周期:产生–&gt;注册–&gt;注销–&gt;处理/阻塞</p><h2 id="信号的种类"><a href="#信号的种类" class="headerlink" title="信号的种类"></a>信号的种类</h2><p><strong>查看方式：kill  -l</strong>，查看Linux下系统定义的信号列表，每个信号都有一个编号和一个宏定义名称,这些宏定义可以在signal.h中找到,这些信号各自在什么条件下 产生,默认的处理动作是什么,在signal(7)中都有详细明:<strong>man7signal</strong></p><p><img src="D:\MyBlog\source\images\signal.png" alt=""></p><p><strong>Linux下系统定义的信号列表</strong>：62种</p><p> <strong>1-31</strong>对应不同的事件     非可靠信号/非实时(事件可能会丢失/是否立即会处理)</p><p> <strong>34-64</strong>用户添加的信号    可靠信号/实时信号</p><p>信号的生命周期:产生–&gt;注册–&gt;注销–&gt;处理     阻塞</p><h2 id="信号的产生"><a href="#信号的产生" class="headerlink" title="信号的产生"></a>信号的产生</h2><h3 id="1-硬件产生"><a href="#1-硬件产生" class="headerlink" title="1.硬件产生:"></a>1.硬件产生:</h3><p>如键盘操作：Ctrl+c Ctrl+l Ctrl+z </p><h4 id="core-dump-解析"><a href="#core-dump-解析" class="headerlink" title="core dump 解析"></a>core dump 解析</h4><p><strong>core dumped :黑匣子,默认关闭,占磁盘资源</strong>当一个进程要异常终止时,可以选择把进程的用户空间内存数据全部 保存到磁 盘上,文件名通常是core,这叫做Core Dump。进程异常终止通常是因为有Bug,比如非法内存访问导致段错误, 事后可以用调试器检查core文件以查清错误原因,这叫做Post-mortem Debug（事后调试）。一个进程允许 产生多大的core文件取决于进程的Resource Limit(这个信息保存 在PCB中)。默认是不允许产生core文件的, 因为core文件中可能包含用户密码等敏感信息,不安全。在开发调试阶段可以用ulimit命令改变这个限制,允许 产生core文件。</p><p> 首先用ulimit命令改变Shell进程的Resource Limit,允许core文件最大为1024K: $ ulimit -c 1024</p><p>进程异常运行时，保存信息到core.pid文件中方便调试</p><p>ulimit -a 查看是否开启0</p><p>ulimit -c  1024 设置大小,开启核心转储文件</p><p>gdb./loop  –&gt; c ore-file core.pid –&gt;bt</p><h3 id="3-软件产生"><a href="#3-软件产生" class="headerlink" title="3.软件产生"></a>3.软件产生</h3><p>kill命令是调用kill（）函数实现的。kill函数可以给一个指定的进程发送指定的信号。</p><p>raise函数可以给当前进程发送指定 的信号(自己给自己发信号)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> signo)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">kill函数可以给一个指定的进程发送指定的信号。</span><br><span class="line">参数：</span><br><span class="line">   给指定进程发送指定信号</span><br><span class="line">   sig 信号种类</span><br><span class="line">返回值：</span><br><span class="line">成功返回<span class="number">0</span>,错误返回<span class="number">-1</span>。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> signo)</span></span>;</span><br><span class="line">参数：</span><br><span class="line">raise函数可以给当前进程发送指定的信号</span><br><span class="line">参数：</span><br><span class="line">sig 信号种类</span><br><span class="line">返回值：</span><br><span class="line">这两个函数都是成功返回<span class="number">0</span>,错误返回<span class="number">-1</span>。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abort</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">给调用进程发送SIGABRT信号</span><br><span class="line">就像<span class="built_in">exit</span>函数一样,<span class="built_in">abort</span>函数总是会成功的,所以没有返回值。</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>;</span><br><span class="line">给调用进程指定时间后发送SIGALRM信号</span><br><span class="line">返回上一个定时器剩余的时间或<span class="number">0</span></span><br><span class="line">参数为<span class="number">0</span>表示取消定时器返回上一个定时器的剩余时间</span><br></pre></td></tr></table></figure><h2 id="信号注册"><a href="#信号注册" class="headerlink" title="信号注册"></a>信号注册</h2><h3 id="信号的相关概念"><a href="#信号的相关概念" class="headerlink" title="信号的相关概念"></a>信号的相关概念</h3><ul><li>实际执行信号的处理动作称为<strong>信号递达</strong>(Delivery) </li><li>信号从产生到递达之间的状态,称为<strong>信号未决</strong>(Pending)。 </li><li>进程可以选择阻塞 (Block )某个信号。 </li><li>被阻塞的信号产生时将保持在未决状态,直到进程解除对此信号的阻塞,才执行递达的动作. </li><li>注意,阻塞和忽略是不同的,只要信号被阻塞就不会递达,而忽略是在递达之后可选的一种处理动作。  </li></ul><h3 id="在内核中的表示"><a href="#在内核中的表示" class="headerlink" title="在内核中的表示"></a>在内核中的表示</h3><p><img src="D:\MyBlog\source\images\sigpending.png" alt=""></p><p>在pcb中做标记：<strong>修改未决信号集合（</strong>位图）中对应的信号位。每个<strong>信号都有两个标志位分别表示阻塞(block)和未决(pending)</strong>,还有一个<strong>函数指针表示处理动作</strong>。信号产生时,内核在进程控制块（pcb）中设置该信号的未决标志,直到信号递达才清除该标志。在上图的例子 中,SIGHUP信号未阻塞也未产生过,当它递达时执行默认处理动作。 SIGINT信号产生过,但正在被阻塞,所以暂时不能递达。虽然它的处理动作是忽略,但在没有解除阻塞之前不能忽略这个信号,因为进程仍有机会改变处理动作之后再解除阻塞。 SIGQUIT信号未产生过,一旦产生SIGQUIT信号将被阻塞,它的处理动作是用户自定义函数sighandler（）。 </p><p>如果在进程解除对某信号的阻塞之前这种信号产生过多次,将如何处理?POSIX.1允许系统递送该信号一次 或多次。Linux是这样实现的:常规信号在递达之前产生多次只计一次,而实时信号在递达之前产生多次可 以依次放在一个队列里（sigqueue）</p><h4 id="sigset"><a href="#sigset" class="headerlink" title="sigset"></a>sigset</h4><p>每个信号只有一个bit的未决标志,非0即1,不记录该信号产生了多少次,阻塞标志也是这样表示的。 因此,未决和阻塞标志可以用相同的数据类型sigset_t来存储,sigset_t称为信号集,这个类型可以表示每个信号 的“有效”或“无效”状态,在阻塞信号集中“有效”和“无效”的含义是该信号是否被阻塞,而在未决信号集中“有 效”和“无效”的含义是该信号是否处于未决状态。下一节将详细介绍信号集的各种操作。 阻塞信号集也叫做当 前进程的信号屏蔽字(Signal Mask),这里的“屏蔽”应该理解为阻塞而不是忽略。 </p><h3 id="信号的注册"><a href="#信号的注册" class="headerlink" title="信号的注册"></a>信号的注册</h3><p><strong>非可靠信号的注册</strong>：判断是否有相同的未决信号，若有，则什么也不做；否则修改位图添加结点</p><p><strong>可靠信号的注册</strong>：是否有相同未决信号的注册，若没有修改位图添加节点；否则直接添加结点</p><h2 id="信号的注销"><a href="#信号的注销" class="headerlink" title="信号的注销"></a>信号的注销</h2><p>非可靠信号注销：删除信号的sigqueue结点，修改位图（非可靠信号只会注册一次）</p><p>可靠信号注册：删除节点，检测是否还有相同信号，若有则位图依然置1否则修改为0</p><h2 id="信号的处理："><a href="#信号的处理：" class="headerlink" title="信号的处理："></a>信号的处理：</h2><h4 id="默认处理方式："><a href="#默认处理方式：" class="headerlink" title="默认处理方式："></a>默认处理方式：</h4><p>操作系统(内核)既定的处理方式—-SIG_DFL，可能是以下的某种类型：</p><p>Treminate：进程被终止(杀死)</p><p>Dump：进程被终止(杀死)，如果可能，创建包含进程执行上下文的核心转储文件(core dump)</p><p>Ignore：信号被忽略</p><p>Stop：进程被停止，即把进程置为TASK_STOPPED状态</p><h4 id="忽略处理方式"><a href="#忽略处理方式" class="headerlink" title="忽略处理方式"></a>忽略处理方式</h4><p>这与默认中的忽略是不同的，该处理方式处理了信号，但是什么都没有做</p><h4 id="​-自定义处理方式"><a href="#​-自定义处理方式" class="headerlink" title="​ 自定义处理方式"></a>​ 自定义处理方式</h4><p>提供一个信号处理函数,要求内核在处理该信号时切换到用户态执行这个处理函数,这种方式称为捕捉Catch)一个信号。<strong>有两个信号无法被阻塞,忽略,自定义SIGKILL,SIGSTOP19</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">sighandler_t</span> signal(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler);</span><br><span class="line">参数：</span><br><span class="line">signum信号编号</span><br><span class="line">handler 函数指针使用函数指针替换signum的处理方式</span><br><span class="line"></span><br><span class="line">SIG_DFL ：默认</span><br><span class="line">SIG_IGN ：忽略</span><br></pre></td></tr></table></figure><h4 id="自定信号处理方式的处理流程："><a href="#自定信号处理方式的处理流程：" class="headerlink" title="自定信号处理方式的处理流程："></a>自定信号处理方式的处理流程：</h4><p>用户态切换回内核态，完毕后准备从内核态切换回用户态的时候去处理信号</p><p>若信号为默认或者忽略处理，则在内核中直接完成，但是信号如果是自定义的处理方式，则需要返回用户态执行信号回调函数，执行完毕后回到内核态没有信号则回到信号主流程</p><p>信号阻塞：阻止信号被递达（暂时不处理信号）在进程pcb中标记 那些信号来了不处理 在进程pcb中有个信号阻塞集，阻塞信号就是在这个集合做标记</p><p>静态条件：</p><p>​    时序的竞争执行：函数的可重入与不可重入（是否进行了）对全局数据的非原子性操作</p><p>关键字：volatile：保持内存可见性—防止编译器过度优化-每次对变量访问都从内存重新获取</p><p>SIGCHLD：子进程退出，操作系统通知父进程，自定义一个SIGCGLD信号处理方式sigcb，当子进程退出操作系统发送信号给父进程直接触发信号回调sigbc用户主要在sigbc中调用wait/wait_pid就可以处理子进程退出</p><p>sigchld是一个非可靠信号，假如有多个子进程同时退出则有可能造成事件丢失导致sigbc只被调用一次，只处理了一个子进程因此需要在sigcb中需要用户循环非阻塞处理子进程退出，直到没有子进程退出</p><p>while（waitpid（-11，NULL，WONOHANG）&gt; 0)//因为&gt;0表示有子进程退出必须用非阻塞，否则没有子进程·退出的时候waitpid将阻塞导致进程无法回到主控流程  </p><h3 id="信号集操作函数"><a href="#信号集操作函数" class="headerlink" title="信号集操作函数"></a>信号集操作函数</h3><h4 id="初始化函数"><a href="#初始化函数" class="headerlink" title="初始化函数"></a>初始化函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">函数sigemptyset初始化<span class="built_in">set</span>所指向的信号集,使其中所有信号的对应bit清零,表示该信号集不包含 任何有效信号。</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">函数sigfillset初始化<span class="built_in">set</span>所指向的信号集,使其中所有信号的对应bit置位,表示 该信号集的有效信号包括系统支持的所有信号</span><br><span class="line">注意：</span><br><span class="line">在使用sigset_ t类型的变量之前,一定要调 用sigemptyset或sigfillset做初始化,使信号集处于确定的</span><br><span class="line">状态。</span><br><span class="line">返回值：</span><br><span class="line">函数都是成功返回<span class="number">0</span>,出错返回<span class="number">-1</span>。</span><br></pre></td></tr></table></figure><h4 id="操作函数"><a href="#操作函数" class="headerlink" title="操作函数"></a>操作函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">初始化<span class="keyword">sigset_t</span>变量之后就可以在调用sigaddset和sigdelset在该信号集中添加或删除某种有效信号。</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span> <span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signo)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signo)</span></span>;</span><br><span class="line">函数都是成功返回<span class="number">0</span>,出错返回<span class="number">-1</span>。</span><br><span class="line"><span class="keyword">int</span> sigismember（<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signo);</span><br><span class="line">sigismember是一个布尔函数,用于判断一个信号集的有效信号中是否包含某种 信号,若包含则返回<span class="number">1</span>,不包含则返回<span class="number">0</span>,出错返回<span class="number">-1</span>。</span><br></pre></td></tr></table></figure><h4 id="阻塞信号信号集"><a href="#阻塞信号信号集" class="headerlink" title="阻塞信号信号集"></a>阻塞信号信号集</h4>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作符总结</title>
      <link href="/2019/01/22/%E6%93%8D%E4%BD%9C%E7%AC%A6%E6%80%BB%E7%BB%93/"/>
      <url>/2019/01/22/%E6%93%8D%E4%BD%9C%E7%AC%A6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p><strong>1.算数操作符:+,-,/,*,%</strong><br>这部分只需注意/,%的除数不可以为零,模运算只能是整型<br><strong>2.移位操作符:&lt;&lt;,&gt;&gt;</strong><br>移位的规则:左移操作:左边抛弃右边补零<br>                   右移操作:逻辑右移:左边用0填充,右边丢弃<br>                                  算数右移:左边用符号位填充,右边丢弃<br> 这里还需要注意位移操作符的对象是整型,进行操作时要考虑是否越界,移位的值必须非负,                               <img src="https://img-blog.csdnimg.cn/20190122155923779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4ODMzMjU3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>标准说明无符号值进行所有移位操作都是逻辑移位,有符号值取决于编译器</p></blockquote><p>所以不建议使用移位操作这样程序的可移植性差<br><strong>位操作:&amp;,|,^</strong><br>操作数必须为整数<br>下面是常见的的使用场景:<br>1)给指定位赋1或0<br>2)一个数中1的个数<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> GetoneCount(<span class="built_in">int</span> <span class="keyword">number</span>) &#123;</span><br><span class="line">true<span class="built_in">int</span> <span class="built_in">count</span> = <span class="number">0</span>;</span><br><span class="line">truefor (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">32</span>; ++i) &#123;</span><br><span class="line">truetrue<span class="keyword">if</span> (<span class="keyword">number</span>&amp;(<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">truetruetrue<span class="built_in">count</span>++;</span><br><span class="line">true&#125;</span><br><span class="line">true<span class="keyword">return</span> <span class="built_in">count</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>求补和逗号操作符</strong><br>1.逗号表达式的值为从左到右最后一个<br> <strong>关系操作符</strong><br> 1.其结果值得类型为整型<br> 2.=,==是不同的<br> 在C语言中=为赋值 ==为比较<br> <strong>逻辑操作符</strong><br> 1.短路求值先左再右<br> 2.&amp;,&amp;&amp;,|,||的区别<br> 逻辑操作用于测试0值和非0值而位操作用于比较操作数中对应的位<br><strong>左值和右值</strong><br>左值标识了一个储存结果值的地点,标识了一个特定的位置,字面值常量也都不是左值<br>这个地址指的是程序员可以获得的<br><strong>操作符的优先级和求值顺序</strong><br> 同一优先级的运算符，结合次序由结合方向所决定。<br>简单记就是：！ &gt; 算术运算符 &gt; 关系运算符 &gt; &amp;&amp; &gt; || &gt; 赋值运算符</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言总结 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
