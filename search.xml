<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++类和对象</title>
      <link href="/2019/08/15/C-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
      <url>/2019/08/15/C-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>信号量</title>
      <link href="/2019/08/15/%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
      <url>/2019/08/15/%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>每个信号表示一种事件，位图注册信号表示进程发生了这个事件，sigqueue节点添加一个表示这个事件发生了一次。</p><p>信号是进程之间时间异步通知的方式，属于软中断</p><p>信号阻塞是阻止信号被递达（暂时不处理信号）在进程pcb中标记 那些信号来了不处理 在进程pcb中有个信号阻塞集，阻塞信号就是在这个集合做标记，当信号需要被处理时进行（pending&amp;~block）操作来判定这个信号需要阻塞还是递达。</p><a id="more"></a><h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>信号的基本认知</strong>:软件的中断,通知时间的发生，（进程之间时间异步通知的方式，属于软中断）</p><p><strong>生命周期</strong>：信号的生命周期:产生–&gt;注册–&gt;注销–&gt;处理/阻塞</p><h2 id="信号的种类"><a href="#信号的种类" class="headerlink" title="信号的种类"></a>信号的种类</h2><p><strong>查看方式：kill  -l</strong>，查看Linux下系统定义的信号列表，每个信号都有一个编号和一个宏定义名称,这些宏定义可以在signal.h中找到,这些信号各自在什么条件下 产生,默认的处理动作是什么,在signal(7)中都有详细明:<strong>man7signal</strong></p><p><img src="D:\MyBlog\source\images\signal.png" alt=""></p><p><strong>Linux下系统定义的信号列表</strong>：62种</p><p> <strong>1-31</strong>对应不同的事件     非可靠信号/非实时(事件可能会丢失/是否立即会处理)</p><p> <strong>34-64</strong>用户添加的信号    可靠信号/实时信号</p><p>信号的生命周期:产生–&gt;注册–&gt;注销–&gt;处理     阻塞</p><h2 id="信号的产生"><a href="#信号的产生" class="headerlink" title="信号的产生"></a>信号的产生</h2><h3 id="1-硬件产生"><a href="#1-硬件产生" class="headerlink" title="1.硬件产生:"></a>1.硬件产生:</h3><p>如键盘操作：Ctrl+c Ctrl+l Ctrl+z </p><h4 id="core-dump-解析"><a href="#core-dump-解析" class="headerlink" title="core dump 解析"></a>core dump 解析</h4><p><strong>core dumped :黑匣子,默认关闭,占磁盘资源</strong>当一个进程要异常终止时,可以选择把进程的用户空间内存数据全部 保存到磁 盘上,文件名通常是core,这叫做Core Dump。进程异常终止通常是因为有Bug,比如非法内存访问导致段错误, 事后可以用调试器检查core文件以查清错误原因,这叫做Post-mortem Debug（事后调试）。一个进程允许 产生多大的core文件取决于进程的Resource Limit(这个信息保存 在PCB中)。默认是不允许产生core文件的, 因为core文件中可能包含用户密码等敏感信息,不安全。在开发调试阶段可以用ulimit命令改变这个限制,允许 产生core文件。</p><p> 首先用ulimit命令改变Shell进程的Resource Limit,允许core文件最大为1024K: $ ulimit -c 1024</p><p>进程异常运行时，保存信息到core.pid文件中方便调试</p><p>ulimit -a 查看是否开启0</p><p>ulimit -c  1024 设置大小,开启核心转储文件</p><p>gdb./loop  –&gt; c ore-file core.pid –&gt;bt</p><h3 id="3-软件产生"><a href="#3-软件产生" class="headerlink" title="3.软件产生"></a>3.软件产生</h3><p>kill命令是调用kill（）函数实现的。kill函数可以给一个指定的进程发送指定的信号。</p><p>raise函数可以给当前进程发送指定 的信号(自己给自己发信号)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> signo)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">kill函数可以给一个指定的进程发送指定的信号。</span><br><span class="line">参数：</span><br><span class="line">   给指定进程发送指定信号</span><br><span class="line">   sig 信号种类</span><br><span class="line">返回值：</span><br><span class="line">成功返回<span class="number">0</span>,错误返回<span class="number">-1</span>。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> signo)</span></span>;</span><br><span class="line">参数：</span><br><span class="line">raise函数可以给当前进程发送指定的信号</span><br><span class="line">参数：</span><br><span class="line">sig 信号种类</span><br><span class="line">返回值：</span><br><span class="line">这两个函数都是成功返回<span class="number">0</span>,错误返回<span class="number">-1</span>。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abort</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">给调用进程发送SIGABRT信号</span><br><span class="line">就像<span class="built_in">exit</span>函数一样,<span class="built_in">abort</span>函数总是会成功的,所以没有返回值。</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>;</span><br><span class="line">给调用进程指定时间后发送SIGALRM信号</span><br><span class="line">返回上一个定时器剩余的时间或<span class="number">0</span></span><br><span class="line">参数为<span class="number">0</span>表示取消定时器返回上一个定时器的剩余时间</span><br></pre></td></tr></table></figure><h2 id="信号注册"><a href="#信号注册" class="headerlink" title="信号注册"></a>信号注册</h2><h3 id="信号的相关概念"><a href="#信号的相关概念" class="headerlink" title="信号的相关概念"></a>信号的相关概念</h3><ul><li>实际执行信号的处理动作称为<strong>信号递达</strong>(Delivery) </li><li>信号从产生到递达之间的状态,称为<strong>信号未决</strong>(Pending)。 </li><li>进程可以选择阻塞 (Block )某个信号。 </li><li>被阻塞的信号产生时将保持在未决状态,直到进程解除对此信号的阻塞,才执行递达的动作. </li><li>注意,阻塞和忽略是不同的,只要信号被阻塞就不会递达,而忽略是在递达之后可选的一种处理动作。  </li></ul><h3 id="在内核中的表示"><a href="#在内核中的表示" class="headerlink" title="在内核中的表示"></a>在内核中的表示</h3><p><img src="D:\MyBlog\source\images\sigpending.png" alt=""></p><p>在pcb中做标记：<strong>修改未决信号集合（</strong>位图）中对应的信号位。每个<strong>信号都有两个标志位分别表示阻塞(block)和未决(pending)</strong>,还有一个<strong>函数指针表示处理动作</strong>。信号产生时,内核在进程控制块（pcb）中设置该信号的未决标志,直到信号递达才清除该标志。在上图的例子 中,SIGHUP信号未阻塞也未产生过,当它递达时执行默认处理动作。 SIGINT信号产生过,但正在被阻塞,所以暂时不能递达。虽然它的处理动作是忽略,但在没有解除阻塞之前不能忽略这个信号,因为进程仍有机会改变处理动作之后再解除阻塞。 SIGQUIT信号未产生过,一旦产生SIGQUIT信号将被阻塞,它的处理动作是用户自定义函数sighandler（）。 </p><p>如果在进程解除对某信号的阻塞之前这种信号产生过多次,将如何处理?POSIX.1允许系统递送该信号一次 或多次。Linux是这样实现的:常规信号在递达之前产生多次只计一次,而实时信号在递达之前产生多次可 以依次放在一个队列里（sigqueue）</p><h4 id="sigset"><a href="#sigset" class="headerlink" title="sigset"></a>sigset</h4><p>每个信号只有一个bit的未决标志,非0即1,不记录该信号产生了多少次,阻塞标志也是这样表示的。 因此,未决和阻塞标志可以用相同的数据类型sigset_t来存储,sigset_t称为信号集,这个类型可以表示每个信号 的“有效”或“无效”状态,在阻塞信号集中“有效”和“无效”的含义是该信号是否被阻塞,而在未决信号集中“有 效”和“无效”的含义是该信号是否处于未决状态。下一节将详细介绍信号集的各种操作。 阻塞信号集也叫做当 前进程的信号屏蔽字(Signal Mask),这里的“屏蔽”应该理解为阻塞而不是忽略。 </p><h3 id="信号的注册"><a href="#信号的注册" class="headerlink" title="信号的注册"></a>信号的注册</h3><p><strong>非可靠信号的注册</strong>：判断是否有相同的未决信号，若有，则什么也不做；否则修改位图添加结点</p><p><strong>可靠信号的注册</strong>：是否有相同未决信号的注册，若没有修改位图添加节点；否则直接添加结点</p><h2 id="信号的注销"><a href="#信号的注销" class="headerlink" title="信号的注销"></a>信号的注销</h2><p>非可靠信号注销：删除信号的sigqueue结点，修改位图（非可靠信号只会注册一次）</p><p>可靠信号注册：删除节点，检测是否还有相同信号，若有则位图依然置1否则修改为0</p><h2 id="信号的处理："><a href="#信号的处理：" class="headerlink" title="信号的处理："></a>信号的处理：</h2><h4 id="默认处理方式："><a href="#默认处理方式：" class="headerlink" title="默认处理方式："></a>默认处理方式：</h4><p>操作系统(内核)既定的处理方式—-SIG_DFL，可能是以下的某种类型：</p><p>Treminate：进程被终止(杀死)</p><p>Dump：进程被终止(杀死)，如果可能，创建包含进程执行上下文的核心转储文件(core dump)</p><p>Ignore：信号被忽略</p><p>Stop：进程被停止，即把进程置为TASK_STOPPED状态</p><h4 id="忽略处理方式"><a href="#忽略处理方式" class="headerlink" title="忽略处理方式"></a>忽略处理方式</h4><p>这与默认中的忽略是不同的，该处理方式处理了信号，但是什么都没有做</p><h4 id="​-自定义处理方式"><a href="#​-自定义处理方式" class="headerlink" title="​ 自定义处理方式"></a>​ 自定义处理方式</h4><p>提供一个信号处理函数,要求内核在处理该信号时切换到用户态执行这个处理函数,这种方式称为捕捉Catch)一个信号。<strong>有两个信号无法被阻塞,忽略,自定义SIGKILL,SIGSTOP19</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">sighandler_t</span> signal(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler);</span><br><span class="line">参数：</span><br><span class="line">signum信号编号</span><br><span class="line">handler 函数指针使用函数指针替换signum的处理方式</span><br><span class="line"></span><br><span class="line">SIG_DFL ：默认</span><br><span class="line">SIG_IGN ：忽略</span><br></pre></td></tr></table></figure><h4 id="自定信号处理方式的处理流程："><a href="#自定信号处理方式的处理流程：" class="headerlink" title="自定信号处理方式的处理流程："></a>自定信号处理方式的处理流程：</h4><p>用户态切换到内核态，完毕后准备从内核态切换回用户态的时候去处理信号若信号为默认或者忽略处理，则在内核中直接完成，但是信号如果是自定义的处理方式，则需要返回用户态执行信号回调函数，执行完毕后回到内核态没有信号则回到信号主流程</p><p><img src="D:\MyBlog\source\images\信号捕捉.png" alt=""></p><h4 id="自定义信号捕捉"><a href="#自定义信号捕捉" class="headerlink" title="自定义信号捕捉"></a>自定义信号捕捉</h4><p>如果信号的处理动作是用户自定义函数,在信号递达时就调用这个函数,这称为捕捉信号。由于信号处理函数的代码 是在用户空间的,处理过程比较复杂,举例如下: 用户程序注册了SIGQUIT信号的处理函数sighandler。 当前正在执行 main函数,这时发生中断或异常切换到内核态。 在中断处理完毕后要返回用户态的main函数之前检查到有信号 SIGQUIT递达。 内核决定返回用户态后不是恢复main函数的上下文继续执行,而是执行sighandler函数,sighandler 和main函数使用不同的堆栈空间,它们之间不存在调用和被调用的关系,是 两个独立的控制流程。 sighandler函数返 回后自动执行特殊的系统调用sigreturn再次进入内核态。 如果没有新的信号要递达,这次再返回用户态就是恢复 main函数的上下文继续执行了。 </p><h5 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction"></a>sigaction</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signo, <span class="keyword">const</span> struct sigaction *act, struct sigaction *oact)</span></span>; </span><br><span class="line">参数：</span><br><span class="line">sigaction函数可以读取和修改与指定信号相关联的处理动作。调用成功则返回<span class="number">0</span>,出错则返回- <span class="number">1</span>。signo</span><br><span class="line">是指定信号的编号。若act指针非空,则根据act修改该信号的处理动作。若oact指针非 空,则通过oact传</span><br><span class="line">出该信号原来的处理动作。act和oact指向sigaction结构体:</span><br><span class="line">将sa_handler赋值为常数SIG_IGN传给sigaction表示忽略信号,赋值为常数SIG_DFL表示执行系统默认动</span><br><span class="line">作,赋值为一个函数指针表示用自定义函数捕捉信号,或者说向内核注册了一个信号处理函 数,该函数返回</span><br><span class="line">值为<span class="keyword">void</span>,可以带一个<span class="keyword">int</span>参数,通过参数可以得知当前信号的编号,这样就可以用同一个函数处理多种信</span><br><span class="line">号。显然,这也是一个回调函数,不是被main函数调用,而是被系统所调用。</span><br><span class="line">当某个信号的处理函数被调用时,内核自动将当前信号加入进程的信号屏蔽字,当信号处理函数返回时自动恢复原来</span><br><span class="line">的信号屏蔽字,这样就保证了在处理某个信号时,如果这种信号再次产生,那么 它会被阻塞到当前处理结束为止。 如果</span><br><span class="line">在调用信号处理函数时,除了当前信号被自动屏蔽之外,还希望自动屏蔽另外一些信号,则用sa_mask字段说明这些需</span><br><span class="line">要额外屏蔽的信号,当信号处理函数返回时自动恢复原来的信号屏蔽字。 sa_flags字段包含一些选项,本章的代码都</span><br><span class="line">把sa_flags设为<span class="number">0</span>,sa_sigaction是实时信号的处理函数</span><br></pre></td></tr></table></figure><h4 id="函数的可重入与不可重入"><a href="#函数的可重入与不可重入" class="headerlink" title="函数的可重入与不可重入"></a>函数的可重入与不可重入</h4><p>一个函数是否可以在多个运行时序中重复调用而不会出现任何问题，在一个函数中是否进行了对全局数据的非原子性操作。</p><p><strong>可重入函数：</strong>在多个时序的运行中重复调用，不会造成异常影响。比如在某个函数的调用中，还没有返回时就再次进入该函数，就称为重入。</p><p><strong>不可重入函数：</strong>不能再多个时序中重复调用，比如malloc和free函数。如果随意的调用则会发生内存泄漏。</p><p>时序的竞争执行：函数的可重入与不可重入（是否进行了）对全局数据的非原子性操作</p><p>关键字：volatile：保持内存可见性—防止编译器过度优化-每次对变量访问都从内存重新获取</p><h4 id="SIGCHLD"><a href="#SIGCHLD" class="headerlink" title="SIGCHLD"></a>SIGCHLD</h4><p>SIGCHLD：子进程退出，操作系统通知父进程，自定义一个SIGCGLD信号处理方式sigcb，当子进程退出操作系统发送信号给父进程直接触发信号回调sigbc用户主要在sigbc中调用wait/wait_pid就可以处理子进程退出sigchld是一个非可靠信号，假如有多个子进程同时退出则有可能造成事件丢失导致sigbc只被调用一次，只处理了一个子进程因此需要在sigcb中需要用户循环非阻塞处理子进程退出，直到没有子进程退出while（waitpid（-11，NULL，WONOHANG）&gt; 0)//因为&gt;0表示有子进程退出必须用非阻塞，否则没有子进程·退出的时候waitpid将阻塞导致进程无法回到主控流程  </p><h3 id="信号集操作函数"><a href="#信号集操作函数" class="headerlink" title="信号集操作函数"></a>信号集操作函数</h3><h4 id="初始化函数"><a href="#初始化函数" class="headerlink" title="初始化函数"></a>初始化函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">函数sigemptyset初始化<span class="built_in">set</span>所指向的信号集,使其中所有信号的对应bit清零,表示该信号集不包含 任何有效信号。</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">函数sigfillset初始化<span class="built_in">set</span>所指向的信号集,使其中所有信号的对应bit置位,表示 该信号集的有效信号包括系统支持的所有信号</span><br><span class="line">注意：</span><br><span class="line">在使用sigset_ t类型的变量之前,一定要调 用sigemptyset或sigfillset做初始化,使信号集处于确定的</span><br><span class="line">状态。</span><br><span class="line">返回值：</span><br><span class="line">函数都是成功返回<span class="number">0</span>,出错返回<span class="number">-1</span>。</span><br></pre></td></tr></table></figure><h4 id="操作函数"><a href="#操作函数" class="headerlink" title="操作函数"></a>操作函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">初始化<span class="keyword">sigset_t</span>变量之后就可以在调用sigaddset和sigdelset在该信号集中添加或删除某种有效信号。</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span> <span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signo)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signo)</span></span>;</span><br><span class="line">函数都是成功返回<span class="number">0</span>,出错返回<span class="number">-1</span>。</span><br><span class="line"><span class="keyword">int</span> sigismember（<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signo);</span><br><span class="line">sigismember是一个布尔函数,用于判断一个信号集的有效信号中是否包含某种 信号,若包含则返回<span class="number">1</span>,不包含则返回<span class="number">0</span>,出错返回<span class="number">-1</span>。</span><br></pre></td></tr></table></figure><h4 id="阻塞信号信号集"><a href="#阻塞信号信号集" class="headerlink" title="阻塞信号信号集"></a>阻塞信号信号集</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">sigset_t</span> *oset)</span></span>; </span><br><span class="line">返回值:若成功则为<span class="number">0</span>,若出错则为<span class="number">-1</span></span><br><span class="line">参数：</span><br><span class="line">如果oset是非空指针,则读取进程的当前信号屏蔽字通过oset参数传出。<span class="number">4</span>如果<span class="built_in">set</span>是非空指针,则 更改进程的信</span><br><span class="line">号屏蔽字,参数how指示如何更改。如果oset和<span class="built_in">set</span>都是非空指针,则先将原来的信号 屏蔽字备份到oset里,然后</span><br><span class="line">根据<span class="built_in">set</span>和how参数更改信号屏蔽字</span><br><span class="line">参数how：</span><br><span class="line">trueSIG_BLOCK:<span class="built_in">set</span>包含了我们希望添加到当前信号屏蔽字的信号相当于mask=mask|<span class="built_in">set</span></span><br><span class="line">trueSIG_UNBLOCK:<span class="built_in">set</span>包含了我们希望从当前信号屏蔽字中解除的阻塞信号相当于mask=mask|~<span class="built_in">set</span></span><br><span class="line">trueSIG_SETMASK:设置当前屏蔽字信号为<span class="built_in">set</span>所指向的值相当于mask = <span class="built_in">set</span></span><br><span class="line">注意：</span><br><span class="line">true如果调用sigprocmask解除了对当前若干个未决信号的阻塞,则在sigprocmask返回前,至少将其中一个信号递</span><br><span class="line">达。</span><br></pre></td></tr></table></figure><h4 id="sigpending"><a href="#sigpending" class="headerlink" title="sigpending"></a>sigpending</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpending</span><span class="params">(<span class="keyword">sigset_t</span>* <span class="built_in">set</span>)</span></span></span><br><span class="line">读取当前进程的未决信号集,通过set参数传出。调用成功则返回0,出错则返回-1。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作符总结</title>
      <link href="/2019/01/22/%E6%93%8D%E4%BD%9C%E7%AC%A6%E6%80%BB%E7%BB%93/"/>
      <url>/2019/01/22/%E6%93%8D%E4%BD%9C%E7%AC%A6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p><strong>1.算数操作符:+,-,/,*,%</strong><br>这部分只需注意/,%的除数不可以为零,模运算只能是整型<br><strong>2.移位操作符:&lt;&lt;,&gt;&gt;</strong><br>移位的规则:左移操作:左边抛弃右边补零<br>                   右移操作:逻辑右移:左边用0填充,右边丢弃<br>                                  算数右移:左边用符号位填充,右边丢弃<br> 这里还需要注意位移操作符的对象是整型,进行操作时要考虑是否越界,移位的值必须非负,                               <img src="https://img-blog.csdnimg.cn/20190122155923779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4ODMzMjU3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>标准说明无符号值进行所有移位操作都是逻辑移位,有符号值取决于编译器</p></blockquote><p>所以不建议使用移位操作这样程序的可移植性差<br><strong>位操作:&amp;,|,^</strong><br>操作数必须为整数<br>下面是常见的的使用场景:<br>1)给指定位赋1或0<br>2)一个数中1的个数<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> GetoneCount(<span class="built_in">int</span> <span class="keyword">number</span>) &#123;</span><br><span class="line">true<span class="built_in">int</span> <span class="built_in">count</span> = <span class="number">0</span>;</span><br><span class="line">truefor (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">32</span>; ++i) &#123;</span><br><span class="line">truetrue<span class="keyword">if</span> (<span class="keyword">number</span>&amp;(<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">truetruetrue<span class="built_in">count</span>++;</span><br><span class="line">true&#125;</span><br><span class="line">true<span class="keyword">return</span> <span class="built_in">count</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>求补和逗号操作符</strong><br>1.逗号表达式的值为从左到右最后一个<br> <strong>关系操作符</strong><br> 1.其结果值得类型为整型<br> 2.=,==是不同的<br> 在C语言中=为赋值 ==为比较<br> <strong>逻辑操作符</strong><br> 1.短路求值先左再右<br> 2.&amp;,&amp;&amp;,|,||的区别<br> 逻辑操作用于测试0值和非0值而位操作用于比较操作数中对应的位<br><strong>左值和右值</strong><br>左值标识了一个储存结果值的地点,标识了一个特定的位置,字面值常量也都不是左值<br>这个地址指的是程序员可以获得的<br><strong>操作符的优先级和求值顺序</strong><br> 同一优先级的运算符，结合次序由结合方向所决定。<br>简单记就是：！ &gt; 算术运算符 &gt; 关系运算符 &gt; &amp;&amp; &gt; || &gt; 赋值运算符</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言总结 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
