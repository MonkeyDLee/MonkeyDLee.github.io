<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="libinxu">
  <!-- Open Graph Data -->
  <meta property="og:title" content="MonkeyDLee">
  <meta property="og:description" content="C/C++">
  <meta property="og:site_name" content="MonkeyDLee">
  <meta property="og:type" content="website">
  <meta property="og:image" content="http://yoursite.com">
  
    <link rel="alternate" href="/atom.xml" title="MonkeyDLee" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>MonkeyDLee</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-dark.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">Untitled Post</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/MonkeyDLee">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:532900395@qq.com">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By libinxu</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2019-08-14</span>
            <span class="time">23:58:14</span>
          </span>
          
        </div>
        <!-- Tags -->
        
        <!-- Post Main Content -->
        <div class="post-content">
          <h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p><strong>产生:</strong></p>
<p>是大佬们针对一些经典的常见的场景, 给定了一些对应的解决方案, 这个就是 设计模式</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p><strong>概念:一个对象只可以(需要)被实例化出一次</strong></p>
<h3 id="单例模式优点："><a href="#单例模式优点：" class="headerlink" title="单例模式优点："></a>单例模式优点：</h3><ol>
<li>在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是相同的一个实例。这样就防   止其它对象对自己的实例化，确保所有的对象都访问一个实例 </li>
<li>单例模式具有一定的伸缩性，类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。 </li>
<li>提供了对唯一实例的受控访问。 </li>
<li>由于在系统内存中只存在一个对象，因此可以 节约系统资源，当 需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能。 </li>
<li>允许可变数目的实例。 </li>
<li>避免对共享资源的多重占用。 </li>
</ol>
<h3 id="单例模式缺点："><a href="#单例模式缺点：" class="headerlink" title="单例模式缺点："></a>单例模式缺点：</h3><ol>
<li>不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不  能保存彼此的状态。 </li>
<li>由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。 </li>
<li>单例类的职责过重，在一定程度上违背了“单一职责原则”。 </li>
<li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。</li>
</ol>
<h3 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h3><p>对象使用的时候再实例化,程序初始化加载快运行时流畅度较差,需要注意线程安全问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;    </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span>                                                                                      </span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">static</span> T* inst;                    </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::mutex lock;                     </span><br><span class="line">    <span class="keyword">public</span>:                                     </span><br><span class="line">    <span class="function"><span class="keyword">static</span> T* <span class="title">GetInstance</span><span class="params">()</span></span>&#123;                    </span><br><span class="line">      <span class="keyword">if</span> (inst == <span class="literal">nullptr</span>)&#123;                     </span><br><span class="line">        lock.lock();                            </span><br><span class="line">        <span class="keyword">if</span>(inst == <span class="literal">nullptr</span>)&#123;                    </span><br><span class="line">          inst = <span class="keyword">new</span> T;                         </span><br><span class="line">        &#125;                                       </span><br><span class="line">        lock.unlock();                          </span><br><span class="line">      &#125;                                         </span><br><span class="line">      <span class="keyword">return</span> inst;                              </span><br><span class="line">    &#125;                                           </span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<h4 id="为啥要加锁"><a href="#为啥要加锁" class="headerlink" title="为啥要加锁:"></a>为啥要加锁:</h4><p><code>instance=new MyManger3();</code>这个语句不是一个原子操作会造成线程不安全,编译后会多条字节码指令：</p>
<ul>
<li>为new出来的对象开辟内存空间</li>
<li>初始化，执行构造器方法的逻辑代码片段</li>
<li>完成instance引用的赋值操作，将其指向刚刚开辟的内存地址</li>
</ul>
<h5 id="线程不安全的场景"><a href="#线程不安全的场景" class="headerlink" title="线程不安全的场景"></a>线程不安全的场景</h5><p>假设两个线程t1,t2先后达到 inst = new T;此时t1执行new操作由于操作不是原子性的,t1可能由于时间片不够</p>
<p>或者其他原因陷入休眠由于没有锁线程t2进入该操作并执行完了new操作,此时t1被唤醒继续创建了一个新的对象</p>
<p>这样就不符合单例模式的规则了</p>
<h5 id="double-check的机制"><a href="#double-check的机制" class="headerlink" title="double check的机制"></a>double check的机制</h5><p>目的是为了提高效率;只有第一个创建对象的线程才需要检验,之后的不需要所以先筛选一下避免过度竞争</p>
<h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><p>程序初始化时已经实例化资源全部加载,因此运行速度快流畅,加载时间很长</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">template</span>  &lt;<span class="keyword">typename</span> T&gt;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">singleton</span>&#123;</span>  </span><br><span class="line">  <span class="keyword">static</span> T data;  </span><br><span class="line">  <span class="keyword">public</span>:  </span><br><span class="line">  <span class="function"><span class="keyword">static</span> T*  <span class="title">GetInstance</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> &amp;data;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="成员变量和GetInstance-是static的原因"><a href="#成员变量和GetInstance-是static的原因" class="headerlink" title="成员变量和GetInstance()是static的原因"></a>成员变量和GetInstance()是static的原因</h3><p>static 确保只在类加载的时候才初始化一次。单例模式是运行的当前虚拟机中有且只有一个需要的对象，不存在重复（通过private构造方法控制不让外界访问）。<br>static 是给类静态成员变量使用的，属于类的属性，一般是一些常量之类的东西，从加载上来说对于类和对象之间，在类加载到内存时候静态成员变量就存在了，而对象还不存在。<br>另外 静态方法只能调用静态方法和静态变量,如果全部搞成静态方法那么意味着其他成员变量都要是静态的，很不方便。</p>
<p>static占用内存，如果对象过多的话会占用非常多，其次安全性很不好，多会被内存溢出攻击影响，整理内存软件对于这样的程序性能影响也很大</p>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        </p><p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  <script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>

