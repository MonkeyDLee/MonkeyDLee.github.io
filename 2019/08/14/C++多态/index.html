<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="libinxu">
  <!-- Open Graph Data -->
  <meta property="og:title" content="MonkeyDLee">
  <meta property="og:description" content="C/C++">
  <meta property="og:site_name" content="MonkeyDLee">
  <meta property="og:type" content="website">
  <meta property="og:image" content="http://yoursite.com">
  
    <link rel="alternate" href="/atom.xml" title="MonkeyDLee" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>MonkeyDLee</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-dark.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">Untitled Post</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/MonkeyDLee">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:532900395@qq.com">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By libinxu</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2019-08-14</span>
            <span class="time">23:58:14</span>
          </span>
          
        </div>
        <!-- Tags -->
        
        <!-- Post Main Content -->
        <div class="post-content">
          <h1 id="C-多态"><a href="#C-多态" class="headerlink" title="C++多态"></a>C++多态</h1><p><strong>概念</strong>:多态的概念：通俗来说，就是多种形态，<strong>具体点就是去完成某个行为，当不同的对象去完成时会产生出不同</strong> </p>
<p><strong>的状态</strong>。举个栗子：比如<strong>买票这个行为</strong>，当<strong>普通人</strong>买票时，是全价买票；<strong>学生</strong>买票时，是半价买票；<strong>军人</strong>买票时是优 先买票。 </p>
<h4 id="多态的定义和实现"><a href="#多态的定义和实现" class="headerlink" title="多态的定义和实现"></a>多态的定义和实现</h4><h5 id="多态的构成条件"><a href="#多态的构成条件" class="headerlink" title="多态的构成条件:"></a>多态的构成条件:</h5><p>不同对象调用同一函数产生了不同的行为。那么在继承中要<strong>构成多态还有两个条件</strong>： </p>
<ol>
<li><p>必须通过基类的指针或者引用调用虚函数 （基类指针引用指向派生类对象才是安全的）</p>
</li>
<li><p>被调用的函数必须是虚函数，且派生类必须对基类的虚函数进行重写 </p>
</li>
</ol>
<p><img src="D:\MyBlog\source\images\多态.png" alt=""></p>
<h5 id="虚函数：即被vitrual修饰的成员函数我们称之为虚函数。"><a href="#虚函数：即被vitrual修饰的成员函数我们称之为虚函数。" class="headerlink" title="虚函数：即被vitrual修饰的成员函数我们称之为虚函数。"></a>虚函数：即被vitrual修饰的成员函数我们称之为虚函数。</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">true<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuyTicket</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">truetrue<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"success"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">true&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="虚函数的重写"><a href="#虚函数的重写" class="headerlink" title="虚函数的重写"></a>虚函数的重写</h5><p>虚函数的重写(覆盖)：<strong>派生类中有一个跟基类完全相同的虚函数</strong>（即派生类虚函数与基类虚函数的返回值类型、函数名字、参数列表完全相同)，称子类的虚函数重写了基类的虚函数。</p>
<p>注意：</p>
<p>​     在重写基类虚函数时，派生类的虚函数在不加virtual关键字时，虽然也可以构成重写(因为继承后基类的虚函数被继承下来了在派生类依旧保持虚函数属性),但是该种写法不是很规范，不建议这样使用</p>
<h5 id="虚函数重写的两个例外："><a href="#虚函数重写的两个例外：" class="headerlink" title="虚函数重写的两个例外："></a>虚函数重写的两个例外：</h5><h6 id="1-协变"><a href="#1-协变" class="headerlink" title="1.协变"></a>1.协变</h6><p>派生类重写基类虚函数时，与基类虚函数返回值类型不同。即基类虚函数返回基类对象的指针或者引 </p>
<p>用，派生类虚函数返回派生类对象的指针或引用时称为协变</p>
<h6 id="2-析构函数的重写（基类与派生类析构函数的名字不同"><a href="#2-析构函数的重写（基类与派生类析构函数的名字不同" class="headerlink" title="2. 析构函数的重写（基类与派生类析构函数的名字不同)"></a>2. 析构函数的重写（基类与派生类析构函数的名字不同)</h6><p>如果基类的析构函数为虚函数，此时派生类析构函数只要定义，<strong>无论是否加virtual关键字，都与基类的</strong> </p>
<p><strong>析构函数构成重写</strong>，虽然基类与派生类析构函数名字不同。虽然函数名不相同，看起来违背了重写的规 </p>
<p>则，其实不然，这里可以理解为编译器对析构函数的名称做了特殊处理，<strong>编译后析构函数的名称统一</strong>处 </p>
<p>理成<strong>destructor</strong>。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~Person() &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~Person()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~Student() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Student()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person* p1 = <span class="keyword">new</span> Person;</span><br><span class="line">Person* p2 = <span class="keyword">new</span> Student;</span><br><span class="line"><span class="keyword">delete</span> p1;</span><br><span class="line"><span class="keyword">delete</span> p2;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<p>只有派生类Student的析构函数重写了Person的析构函数，下面的delete对象调用析构函数，才能构成 </p>
<p>多态，才能保证p1和p2指向的对象正确的调用析构函数。</p>
<h5 id="C-11-override和-final"><a href="#C-11-override和-final" class="headerlink" title="C++11 override和 final"></a>C++11 override和 final</h5><ol>
<li><strong>final：修饰虚函数，表示该虚函数不能再被继承</strong></li>
<li><strong>override:</strong> <strong>检查派生类虚函数是否重写了基类某个虚函数，如果没有重写编译报错。</strong></li>
</ol>
<h5 id="重载，覆盖（重写），隐藏（重定义）的区别"><a href="#重载，覆盖（重写），隐藏（重定义）的区别" class="headerlink" title="重载，覆盖（重写），隐藏（重定义）的区别"></a>重载，覆盖（重写），隐藏（重定义）的区别</h5><p><img src="D:\MyBlog\source\images\隐藏重写重载.png" alt=""></p>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>在虚函数的后面写上 =0 ，则这个函数为纯虚函数。<strong>包含纯虚函数的类叫做抽象类（也叫接口类），抽象类</strong> </p>
<p><strong>不能实例化出对象</strong>。派生类继承后也不能实例化出对象，只有重写纯虚函数，派生类才能实例化出对象。纯 </p>
<p>虚函数规范了派生类必须重写，另外纯虚函数更体现出了接口继承。</p>
<p><strong>接口继承和现实继承</strong>：</p>
<p>普通函数的继承是一种实现继承，<strong>派生类继承了基类函数，可以使用函数，继承的是函数的实现</strong>。虚函数的 </p>
<p>继承是一种接口继承，派生类继承的是基类虚函数的接口，目的是为了重写，达成多态，继承的是接口。所 </p>
<p>以如果不实现多态，不要把函数定义成虚函数。</p>
<h4 id="多态实现的原理"><a href="#多态实现的原理" class="headerlink" title="多态实现的原理"></a>多态实现的原理</h4><h5 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> &#123;</span></span><br><span class="line">true<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">truetrue<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"haa"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">true&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">true<span class="keyword">int</span> _test;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过观察测试我们发现test类是8bytes，除了成员变量_test，还多一个vfptr放在对象的前面(注意有些平台可能会放到对象的最后面，这个跟平台有关),对象中的这个指针我们叫做虚函数表指针(v代表virtual，f代表function)。一个含有虚函数的类中都至少都有一个虚函数表指针，因为虚函数的地址要被放到虚函数表中， 虚函数表也简称虚表。</p>
<p><img src="D:\MyBlog\source\images\虚表指针.png" alt=""></p>
<p><strong>补充</strong>：</p>
<p>1.虚函数表本质是一个存<strong>虚函数指针的指针数组</strong>，这个数组最后面放了一个nullptr。</p>
<p>2.派生类的虚表生成：</p>
<p>a.先将基类中的虚表内容拷贝一份到派生类虚表中</p>
<p> b.如果派生类重写了基类中某个虚函数，用派生类自己的虚函数覆盖虚表中基类的虚函数 </p>
<p> c.派生类自己新增加的虚函数按其在派生类中的声明次序增加到派生类虚表的最后。</p>
<p><img src="D:\MyBlog\source\images\虚表指针内容.png" alt=""></p>
<p><strong>注意</strong></p>
<p><strong>虚表存的是虚函数指针，不是虚函数</strong>，虚函数和普通函数一样的，都是存在<strong>代码段的</strong>，只是他的指针又存到了虚表中。另外 对象中存的不是虚表，存的是虚表指针。</p>
<h5 id="多态实现的原理-1"><a href="#多态实现的原理-1" class="headerlink" title="多态实现的原理"></a>多态实现的原理</h5><ol>
<li>基类对象和派生类对象调用虚函数时在虚表中找的函数是不一样的。</li>
<li>这样就实现出了不同对象去完成同一行为时，展现出不同的形态。 </li>
<li>反过来思考我们要达到多态，有两个条件，一个是虚函数覆盖，一个是基类对象的指针或引用调用虚函数。 反思一下为什么？因为基类指针指向派生类对象是安全的 而派生类指向基类的地址是放大了范围是不安全的。</li>
<li><strong>满足多态以后的函数调用，不是在编译时确定的，是运行起来以后到对象的中取找的。不满足多态的函数调  用时编译时确认好的</strong></li>
</ol>
<h5 id="动态绑定与静态绑定"><a href="#动态绑定与静态绑定" class="headerlink" title="动态绑定与静态绑定"></a>动态绑定与静态绑定</h5><ol>
<li><p>静态绑定又称为前期绑定(早绑定 )，<strong>在程序编译期间确定了程序的行为</strong>，<strong>也称为静态多态</strong>，比如：函数重载 </p>
</li>
<li><p>动态绑定又称后期绑定(晚绑定)，是在程序运行期间，根据具体拿到的类型确定程序的具体行为，调用 具体的函数，<strong>也称为动态多态</strong>。  </p>
</li>
</ol>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        </p><p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  <script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>

