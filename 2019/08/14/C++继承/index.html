<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="libinxu">
  <!-- Open Graph Data -->
  <meta property="og:title" content="MonkeyDLee">
  <meta property="og:description" content="C/C++">
  <meta property="og:site_name" content="MonkeyDLee">
  <meta property="og:type" content="website">
  <meta property="og:image" content="http://yoursite.com">
  
    <link rel="alternate" href="/atom.xml" title="MonkeyDLee" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>MonkeyDLee</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-dark.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">Untitled Post</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/MonkeyDLee">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:532900395@qq.com">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By libinxu</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2019-08-14</span>
            <span class="time">23:58:14</span>
          </span>
          
        </div>
        <!-- Tags -->
        
        <!-- Post Main Content -->
        <div class="post-content">
          <h1 id="C-继承"><a href="#C-继承" class="headerlink" title="C++继承"></a>C++继承</h1><h4 id="继承的概念-："><a href="#继承的概念-：" class="headerlink" title="继承的概念 ："></a>继承的概念 ：</h4><p>​    <strong>继承</strong>(inheritance)机制是面向对象程序设计<strong>使代码可以复用</strong>的最重要的手段，它允许程序员在<strong>保持原有类特</strong> </p>
<p><strong>性的基础上进行扩展</strong>，增加功能，这样产生新的类，称派生类。继承<strong>呈现了面向对象程序设计的层次结构</strong>， </p>
<p>体现了由简单到复杂的认知过程。以前我们接触的复用都是函数复用，<strong>继承是类设计层次的复用</strong>。</p>
<h4 id="继承基类成员访问方式的变化"><a href="#继承基类成员访问方式的变化" class="headerlink" title="继承基类成员访问方式的变化"></a>继承基类成员访问方式的变化</h4><p><img src="D:\MyBlog\source\images\继承基类访问变化表.png" alt=""></p>
<p><strong>总结：</strong> </p>
<ol>
<li>基类private成员在派生类中无论以什么方式继承都是不可见的。这里的<strong>不可见是指基类的私有成员还是</strong> <strong>被继承到了派生类对象中，但是语法上限制派生类对象不管在类里面还是类外面都不能去访问它</strong>。 </li>
<li>基类private成员在派生类中是不能被访问，如果基类成员不想在类外直接被访问，但需要在派生类中能 访问，就定义为protected。<strong>可以看出保护成员限定符是因继承才出现的</strong>。</li>
<li>实际上面的表格我们进行一下总结会发现，基类的私有成员在子类都是不可见。基类的其他成员在子类 的访问方式 == Min(成员在基类的访问限定符，继承方式)，public &gt; protected &gt; private。</li>
<li>使用关键字<strong>class时默认的继承方式是private</strong>，<strong>使用struct时默认的继承方式是public</strong>，<strong>不过最好显示的</strong> <strong>写出继承方式</strong>。 </li>
<li><strong>在实际运用中一般使用都是**</strong>public继承，几乎很少使用<strong>protetced/private继承</strong>，也不提倡使用 protetced/private继承，因为protetced/private继承下来的成员都只能在派生类的类里面使用，实际中 扩展维护性不强。</li>
</ol>
<h4 id="基类和派生类对象赋值转换"><a href="#基类和派生类对象赋值转换" class="headerlink" title="基类和派生类对象赋值转换"></a>基类和派生类对象赋值转换</h4><ol>
<li><strong>派生类对象</strong> 可以赋值给 <strong>基类的对象</strong> <strong>/</strong> <strong>基类的指针</strong> <strong>/</strong> <strong>基类的引用</strong>。这里有个形象的说法叫切片或者切割。寓意把派生类中父类那部分切来赋值过去。 </li>
<li>基类对象不能赋值给派生类对象 <strong>基类的指针可以通过强制类型转换赋值给派生类的指针</strong>。但是必须是基类的指针是指向派生类对象时才是安全的。这里基类如果是多态类型，可以使用RTTI(Run-TimeTypeInformation)的dynamic_cast 来 进行识别后进行安全转换。</li>
</ol>
<p><img src="D:\MyBlog\source\images\分片.png" alt=""></p>
<h4 id="继承中的作用域"><a href="#继承中的作用域" class="headerlink" title="继承中的作用域"></a>继承中的作用域</h4><ul>
<li>在继承体系中<strong>基类</strong>和<strong>派生类</strong>都有<strong>独立的作用域</strong>。 </li>
<li>子类和父类中有同名成员，<strong>子类成员将屏蔽父类对同名成员的直接访问，这种情况叫隐藏，也叫重定</strong> <strong>义。</strong>（在子类成员函数中，可以<strong>使用 基类**</strong>::<strong>*基类成员 显示访问</strong>）</li>
<li>需要注意的是如果是成员函数的隐藏，只需要函数名相同就构成隐藏。 </li>
<li>注意在实际中在<strong>继承体系里</strong>面最好<strong>不要定义同名的成员</strong>。 </li>
</ul>
<h4 id="派生类的默认成员函数"><a href="#派生类的默认成员函数" class="headerlink" title="派生类的默认成员函数"></a>派生类的默认成员函数</h4><p>6个默认成员函数，那么在派生类中，这几个    成员函数是如何生成的呢？ </p>
<ol>
<li>派生类的构造函数必须调用基类的构造函数初始化基类的那一部分成员。如果基类没有默认的构造函 </li>
</ol>
<p>数，则必须在派生类构造函数的初始化列表阶段显示调用。 </p>
<ol start="2">
<li><p>派生类的拷贝构造函数必须调用基类的拷贝构造完成基类的拷贝初始化。 </p>
</li>
<li><p>派生类的operator=必须要调用基类的operator=完成基类的复制。 </p>
</li>
<li><p>派生类的析构函数会在被调用完成后自动调用基类的析构函数清理基类成员。因为这样才能保证派生类 </p>
</li>
</ol>
<p>对象先清理派生类成员再清理基类成员的顺序。 </p>
<ol start="5">
<li><p>派生类对象初始化先调用基类构造再调派生类构造。 </p>
</li>
<li><p>派生类对象析构清理先调用派生类析构再调基类的析构。</p>
</li>
</ol>
<p><img src="D:\MyBlog\source\images\派生类的默认成员函数.png" alt=""></p>
<h4 id="继承与友元"><a href="#继承与友元" class="headerlink" title="继承与友元"></a>继承与友元</h4><p><strong>友元关系不能继承</strong>，也就是说基类友元不能访问子类私有和保护成员</p>
<h4 id="继承与静态成员"><a href="#继承与静态成员" class="headerlink" title="继承与静态成员"></a>继承与静态成员</h4><p><strong>基类定义了**</strong>static静态成员，则整个继承体系里面只有一个这样的成员**。无论派生出多少个子类，都只有一个static成员实例 。 </p>
<h4 id="复杂的菱形继承及菱形虚拟继承"><a href="#复杂的菱形继承及菱形虚拟继承" class="headerlink" title="复杂的菱形继承及菱形虚拟继承"></a>复杂的菱形继承及菱形虚拟继承</h4><p> <strong>单继承：一个子类只有一个直接父类时称这个继承关系为单继承</strong></p>
<p><strong>多继承：一个子类有两个或以上直接父类时称这个继承关系为多继承</strong></p>
<p><strong>菱形继承：菱形继承是多继承的一种特殊情况</strong></p>
<p><strong>菱形继承的问题：从下面的对象成员模型构造，可以看出菱形继承有数据冗余和二义性的问题。</strong></p>
<p><strong>解决办法虚继承</strong></p>
<p>虚拟继承可以解决菱形继承的二义性和数据冗余的问题。<strong>需要注意的是，虚拟继承不要在其他地方去使用</strong></p>
<h4 id="虚继承解决菱形继承的原理"><a href="#虚继承解决菱形继承的原理" class="headerlink" title="虚继承解决菱形继承的原理"></a>虚继承解决菱形继承的原理</h4><p>虚继承底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类表依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。实际上，vbptr指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与<strong>本类的偏移地址</strong>；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。</p>
<p><img src="D:\MyBlog\source\images\虚基表.png" alt=""></p>
<h4 id="继承和组合"><a href="#继承和组合" class="headerlink" title="继承和组合"></a>继承和组合</h4><p>public继承是一种<strong>is-a</strong>的关系。也就是说每个派生类对象都是一个基类对象。 </p>
<p>组合是一种<strong>has-a</strong>的关系。假设B组合了A，每个B对象中都有一个A对象。 </p>
<p>优先使用对象组合，而不是类继承 。 </p>
<p>继承允许你根据基类的实现来定义派生类的实现。这种通过生成派生类的复用通常被称为白箱复用 </p>
<p>(white-box reuse)。术语“白箱”是相对可视性而言：在继承方式中，基类的内部细节对子类可见 。 </p>
<p>继承一定程度破坏了基类的封装，基类的改变，对派生类有很大的影响。派生类和基类间的依赖关 </p>
<p>系很强，耦合度高。 </p>
<p>对象组合是类继承之外的另一种复用选择。新的更复杂的功能可以通过组装或组合对象来获得。对 </p>
<p>象组合要求被组合的对象具有良好定义的接口。这种复用风格被称为黑箱复用(black-box reuse)， </p>
<p>因为对象的内部细节是不可见的。对象只以“黑箱”的形式出现。 组合类之间没有很强的依赖关系， </p>
<p>耦合度低。优先使用对象组合有助于你保持每个类被封装。比特科技 </p>
<p>实际尽量多去用组合。组合的耦合度低，代码维护性好。不过继承也有用武之地的，有些关系就适 </p>
<p>合继承那就用继承，另外要实现多态，也必须要继承。类之间的关系可以用继承，可以用组合，就 </p>
<p>用组合。</p>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        </p><p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  <script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>

